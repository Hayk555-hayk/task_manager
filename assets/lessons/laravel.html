<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LARAVEL</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>

    <div class="theme_wrapper">
        <div>
            <a href="../../index.html">BACK</a>
            <p>Surfside Media; lumen-Code Step By Step; orchid-agoalofalife (Видео 8)</p>
        </div>
        <div>Для установки проекта нужна команда composer create-project laravel/laravel example-app</div>
        <div>В composer.json находятся зависимости проекта</div>
        <div>Для начала проекта нужна команда php artisan serve</div>
        <div>
            Роутинг происходит в  web и api php файлах 
            Пример роута
            <pre>
Rpote::get('/path', [Controller::class, 'method'])->name('some name for this route')
Route::get('/path/{user_id}, [Controller::class, 'method])
            </pre>
            В методe у контроллера такие аргументы принимаются как обычные аргументы
            Пример такого метода 
            <pre>
public function some_method($user_id) {
    logic here ...
}
            </pre>
            Такие параметры могут быть необьязательными, where после route создаст критерии для переданного аргумента
            <pre>
Route::get('/path/{user_id?}, [Controller::class, 'method])->where('user_id', 'some regular expression')
public function some_method($user_id = null) {
    logic here ...
}
            </pre>
            Эти where могут быть и глобальными, в providers/RouteServiceProvider внутри метода booth
            под всей логикой можем прописать 
            <pre>
Route::pattern('user_id', 'some regular expression');
            </pre>
            Можно прописать route и для post и для get
            <pre>
Route::match(['get', 'post'], '/path', [Controller::class, 'method'])
Route::any('/path', [Controller::class, 'method'])
// To get the requested method
public function some_method(Request $req) {
    dd($req->method());
}
            </pre>
        </div>
        <div>
            В контроллерах пишется вся логика приложения, для создания контроллера используем
            команду php artisan make:controller NameController
        </div>
        <div>
            Общий вид по умолчанию в приложениях ларавел создается шаблонизатором blade 
            они находятся в папке resources/views 
            <pre>
public function some_method($name) {
    $user_name = $name;
    return view('users', compact('user_name')); // but the file name is users.blade.php
}
//В blade Интерполяция происходит благодаря {{$user_name}}
            </pre>
        </div>
        <div>
            Создания blade компонента происходит при помощи php artisan make:component ComponentName команды
            Команда создаст 2 файла, первый app/views/created php file, второй resources/views/components/blade файл <br />
            Для вызова этого компонента в нужном blade пропишем ноый тег, через пропсы можно передавать данные x-componentName name="Hayk" :fruits="$fruits"
            и для того чтобы этод name был виден нужно в php файле компонента прописать следующий команда
            <pre>
class Header extends Component {
    public $name;

    public function __construct($name) {
        $this->name = $name; // This name is available in Header blade as {{$name}}
    }
}
            </pre>
        </div>
        <div>
            Для создания контроллера нужна команда php artisan make:controller NameController, а команда 
            php artisan serve запускает сервер
        </div>
        <div>jsonplaceholder является хорошим местом для фейк api</div>
        <div>
            Создаем запрос на другой ресурс из нашего проекта 
            <pre>
public function makeRequest() {
    //GET EXAMPLE
    $request = Http::get('url');
    //POST EXAMPLE
    $request = Http::post('url', [data]);
    // PUT EXAMPLE
    $request = Http::put('url', [data]);
    //DELETE EXAMPLE
    $request = Http::delete('url');

    return $requrst->json();
}
            </pre>
        </div>
        <div>
            Работа со строками 
            <pre>
$str = Str::of('Welcome to tutorial')->after('Welcome to'); // will show tutoral
$str = Str::of('Welcome\ to\ tutorial')->afterLast('\\'); // will show tutoral
$str = Str::of('Welcome')->append(' to totorial'); // will show Welcom to tutoral
$str = Str::of('WELCOME')->lower(); // will show welcome (same for upper)
$str = Str::of('Welcome here')->replace('here', 'there'); // will show Welcome there
$str = Str::of('this is a title')->title(); // will show This Is A Titile
$str = Str::of('welcome to tutorial')->slug('-'); // will show welcome-to-tutorial
$str = Str::of('welcome here')->substr(8); // will show here
$str = Str::of('/laravel/')->trim('/'); // will show laravel
            </pre>
        </div>






        <div>
            Laravel & websocket. Polling это создания realtime при помощи ежесекундном http запросе, но это очень не эффективно. 
            Чтобы в laravel заработал websocket нужен pusher. Larawel websockets предоставляет бесплатный pusher 
            <pre>
$ composer require beyondcode/laravel-websockets // install package for websockets
php artisan migrate // Migrate  all databases for websocket
config/websocket.php - allow_origin // All origins for connecting to our websocket server 
$ composer require pusher/pusher-php-server // additional dependency 

// Change broadcast_driver in env to pusher, also add some values for pusher_app_id, pusher_app_key, pusher_app_secret, queue_connection = sync
// broadcasting config 
in pusher array in options add few options 
useTls = false
encripted = false 
host
port = 6001
scheme http
php artisan websockets:serve // wil lstart websocket

// new route is created larawel-websockets to see websocket dashboard, click to connect if you see chart that is mean that everything is ok 

//unkomment broadcastserviceprovider in config/websockets
// chanels similar to routes
Broadcast::channel('App.Models.User.{id}', function($user, $id) {
    return $id;
}); 

// Creating even 
php artisan make:event NameEvent
add to class name implements ShoulBroadcast, in boradcastOn we define chanel, change 
privatChanelClass to Chanel class to establish public chanel, names should be separated by dot ('public.playground')
// In web routes there should be /playgrounds path where we can do the next 
event(new App\Events\PlaygroundEvent());

//creating our own function name instead of Playground
in Created event add the next 
public function broadcastAs(){
    return 'playground';
}

// returning data in the same file add 
public function broadcastWith() {
    //logic to collect the data
    return $data;
}

//Для подписки нужно npm install laravel-echo pusher-js
// npm run hot
const chanel = Echo.channel('public.playground.1')
// getting data from webspcket
channel.subscribed(() => {
    console.log('subscribed');
}).listen('.playground', (event) => {
    
})
            </pre>
            Существует 3 типа каналов public (no authnrequired), private (no one can see who make the post), presence (everyone can see who make the post)
        </div>
    </div>
    
</body>
</html>

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЗАДАЧИ</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <main>
        <div class="text">
            <h3>C#</h3>
            Программа на C# состоит из классов и методов. Главный метод программы называется Main.
            Это точка входа, с которой начинается выполнение программы.
        </div>
        <div class="code">
            using System; // Подключение пространства имен для работы с консолью

            class Program // Объявление класса
            {
                static void Main() // Главный метод программы
                {
                Console.WriteLine("Hello, World!"); // Вывод текста в консоль
                }
            }

            int number = 10; // Целое число
            double pi = 3.14; // Число с плавающей точкой
            char letter = 'A'; // Символ
            string name = "Alice"; // Строка
            bool isActive = true; // Логический тип (true или false)
        </div>
        <div class="text">
            using System; — подключение пространства имен System, которое содержит стандартные классы, например, для работы с консолью.<br />
            class Program — определение класса Program.<br />
            static void Main() — метод Main, который будет выполнен при запуске программы. Он должен быть статическим,
            потому что вызывается без создания экземпляра класса.<br />
            Console.WriteLine("Hello, World!"); — команда, которая выводит строку на экран.<br />
            Для управления потоком программы в C# используются условные операторы и циклы.<br />
        </div>
        <div class="code">
            if (a > b)
            {
                Console.WriteLine("a больше b");
            }
            else
            {
                Console.WriteLine("a меньше или равно b");
            }

            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine(i); // Выводит числа от 0 до 4
            }

            int counter = 0;
            while (counter < 5)
            {
                Console.WriteLine(counter);
                counter++;
            }
        </div>
        <div class="text">
            Методы — это блоки кода, которые можно вызвать для выполнения определенной задачи.
        </div>
        <div class="code">
            class Program
            {
                static void Main()
                {
                    GreetUser("Alice"); // Вызов метода
                }

                static void GreetUser(string name)
                {
                    Console.WriteLine($"Hello, {name}!");
                }
            }
        </div>
        <div class="text">
            Класс — это шаблон для создания объектов. Он объединяет данные (поля) и методы (функции, работающие с этими данными).
        </div>
        <div class="code">
            class Person
            {
                // Поля (переменные внутри класса)
                public string Name;
                public int Age;

                // Метод (функция, связанная с объектом)
                public void Introduce()
                {
                    Console.WriteLine($"Привет! Меня зовут {Name}, мне {Age} лет.");
                }
            }
            --------------------------------------------------------------
            using System;

            class Program
            {
                static void Main()
                {
                    // Создаем объект класса Person
                    Person person1 = new Person();
                    person1.Name = "Айк";
                    person1.Age = 31;

                    person1.Introduce(); // Вызываем метод объекта
                }
            }
        </div>
        <div class="text">
            Вместо того чтобы заполнять поля вручную, можно использовать конструктор:
            Конструкторы можно перегружать - создавать несколько конструкторов с разными количествами аргументов 
        </div>
        <div class="code">
            class Person
            {
                public string Name;
                public int Age;

                // Конструктор
                public Person(string name, int age)
                {
                    Name = name;
                    Age = age;
                }

                public void Introduce()
                {
                    Console.WriteLine($"Привет! Меня зовут {Name}, мне {Age} лет.");
                }
            }
        </div>
        <div class="text">
            Свойства позволяют контролировать доступ к данным внутри класса:
        </div>
        <div class="code">
            class Person
            {
                public string Name { get; set; } // Автосвойство
                private int _age; // Приватное поле

                public int Age
                {
                    get { return _age; }
                    set
                    {
                        if (value < 0) 
                            throw new ArgumentException("Возраст не может быть отрицательным!");
                        _age = value;
                    }
                }

                public Person(string name, int age)
                {
                    Name = name;
                    Age = age;
                }

                public void Introduce()
                {
                    Console.WriteLine($"Привет! Меня зовут {Name}, мне {Age} лет.");
                }
            }
        </div>
        <div class="text">
            Структуры похожи на классы, но используются для простых объектов (например, координаты точки).
            Отличие struct от class:
            struct хранится в стеке, а class — в куче (heap).
            struct передается по значению, а class — по ссылке.
            struct не поддерживает наследование.
            DateTime это Strict.
        </div>
        <div class="code">
            struct Point
            {
                public int X;
                public int Y;

                public Point(int x, int y)
                {
                    X = x;
                    Y = y;
                }

                public void Print()
                {
                    Console.WriteLine($"Точка: ({X}, {Y})");
                }
            }
        </div>
        <div class="text">
            Интерфейс определяет контракт (какие методы должен реализовать класс), но не содержит их реализацию.
            Преимущества интерфейсов:
            Позволяют гибко строить архитектуру.
            Используются для полиморфизма.
            Применяются в Dependency Injection
        </div>
        <div class="code">
            interface IMovable
            {
                void Move(int distance);
            }

            class Car : IMovable
            {
                public string Model { get; set; }

                public Car(string model)
                {
                    Model = model;
                }

                public void Move(int distance)
                {
                    Console.WriteLine($"{Model} проехал {distance} км.");
                }
            }
        </div>
        <div class="text">
            Объектно-ориентированное программирование — это парадигма программирования, которая организует код вокруг объектов и данных, а не действий и логики.
            Это позволяет создать структуру программы, которая легче поддерживается и расширяется. 
            Основные концепты ООП включают:<br />
            Инкапсуляция — это принцип, при котором данные (поля) и методы (функции), которые с ними работают, объединяются в одном объекте. 
            Это позволяет скрыть детали реализации и показать только нужные интерфейсы.
            Пример: в классе "Автомобиль" можно инкапсулировать данные о марке, модели, скорости, а методы будут отвечать за управление этими данными, 
            например, "Ускорить", "Тормозить".<br />
            Наследование — это механизм, который позволяет создавать новый класс на основе существующего, что позволяет повторно использовать 
            код и создавать иерархию классов.
            Пример: класс "Мотоцикл" может наследовать от класса "Транспортное средство", добавляя свои уникальные характеристики и поведение.<br />
            Полиморфизм — это способность объектов разных типов реагировать на одни и те же сообщения (методы) по-разному.
            Пример: метод "Звук" может работать по-разному в классе "Автомобиль" и в классе "Мотоцикл". В первом случае это будет звук двигателя, а во втором — звук работы мотора.
        </div>
        <div class="text">
            .NET Framework — это платформа, предназначенная для разработки приложений, в основном для Windows.
            Она существует с 2002 года и включает в себя: <br />
            CLR (Common Language Runtime) — среда выполнения, которая управляет выполнением кода. <br />
            BCL (Base Class Library) — набор стандартных библиотек для разработки приложений. <br />
            Программы на .NET Framework ограничены Windows, то есть они не могут быть легко перенесены на другие операционные системы. <br />

            .NET Core — это кросс-платформенная версия .NET Framework, которая была представлена в 2016 году.
            Она решает проблему совместимости и открывает путь для разработки приложений, которые могут работать на Windows, Linux и macOS.
            Основные особенности: <br />
            Кросс-платформенность: можно разрабатывать и запускать приложения на различных операционных системах.<br />
            Модульность: можно подключать только те библиотеки, которые нужны в проекте.<br />
            Прозрачность: проект был с открытым исходным кодом с самого начала.<br />
            ASP.NET Core: это платформа для разработки веб-приложений, которая также была выпущена как часть .NET Core.<br />

            .NET 5 и последующие версии (.NET 6/7/8) <br />
            С 2020 года Microsoft объединяет .NET Core и .NET Framework в одну платформу, начиная с версии .NET 5.
            Это решение позволяет упростить экосистему, и теперь вся платформа называется просто .NET.
            Следующие версии — .NET 6, .NET 7, .NET 8 — являются развитием этой единой платформы.<br />
            Кросс-платформенность: начиная с .NET 5, разработка приложений поддерживает Windows, Linux и macOS, а также мобильные и
            облачные платформы.<br />
            Поддержка долгосрочной стабильности: .NET 6, например, является LTS-версией (Long Term Support), что
            означает долгосрочную поддержку для стабильных приложений.<br />
            Поддержка новых технологий: .NET 6/7/8 имеют улучшения в производительности, оптимизацию работы с памятью и поддержку
            современных технологий, таких как контейнеризация и микросервисы.<br />
            С 2020 года Microsoft объединяет .NET Core и .NET Framework в одну платформу, начиная с версии .NET 5. 
            Это решение позволяет упростить экосистему, и теперь вся платформа называется просто .NET. Следующие версии — .NET 6, 
            .NET 7, .NET 8 — являются развитием этой единой платформы.<br />
            Кросс-платформенность: начиная с .NET 5, разработка приложений поддерживает Windows, 
            Linux и macOS, а также мобильные и облачные платформы.<br />
            Поддержка долгосрочной стабильности: .NET 6, например, является LTS-версией (Long Term Support), что означает долгосрочную поддержку для 
            стабильных приложений.<br />
            Поддержка новых технологий: .NET 6/7/8 имеют улучшения в производительности, оптимизацию работы с памятью и поддержку современных технологий,
            таких как контейнеризация и микросервисы.<br />
            Основные отличия:<br />
            .NET Framework — работает только на Windows.<br />
            .NET Core — кросс-платформенный, но поддерживает меньше технологий и фреймворков.<br />
            .NET (после .NET 5) — объединение всех платформ в одну с кросс-платформенностью и современными улучшениями.
        </div>
        <div class="text">
            Асинхронность позволяет выполнять операции без блокировки потока, что важно для повышения производительности и отклика в приложениях,
            особенно в многозадачных или I/O-ориентированных системах.<br />
            async — это модификатор, который применяется к методу. Он указывает, что метод будет выполняться асинхронно.<br />
            await — используется внутри асинхронного метода для приостановки выполнения, ожидая завершения асинхронной операции.
            Когда операция завершена, выполнение метода продолжается.<br />
            Task — представляет собой операцию, которая будет завершена в будущем. Возвращаемое значение Task или Task&lt;T&gt;<br />
            (если возвращаемое значение метода не void) указывает на задачу, которая будет выполнена асинхронно.<br />
            Когда метод помечен как async, он возвращает Task (или Task&lt;T&gt;, если возвращаемое значение метода имеет тип). <br />
            Если метод не возвращает ничего (т.е. void), он все равно должен быть асинхронным, но его использование ограничено.
        </div>
        <div class="code">
            public async Task&lt;string&gt; GetDataAsync()
            {
            // Имитируем асинхронную операцию (например, HTTP-запрос)
            await Task.Delay(2000);  // Ожидаем 2 секунды без блокировки потока
            return "Данные получены";
            }
        </div>
        <div class="text">
            Task Parallel Library — это мощный инструмент для работы с многозадачностью в C#.
            Он предоставляет возможность создавать и управлять задачами параллельно. Это особенно полезно для выполнения операций в фоновом режиме,
            таких как вычисления или операции ввода/вывода.<br />
            Основные методы TPL:<br />
            Task.Run — создает задачу, которая будет выполнена в пуле потоков.<br />
            Task.WhenAll — позволяет ожидать завершения нескольких задач.<br />
            Task.WhenAny — ожидает завершения первой из нескольких задач.<br />
        </div>
        <div class="code">
            public void ParallelTaskExample()
            {
                Task[] tasks = new Task[3];
                for (int i = 0; i < 3; i++)
                {
                    tasks[i] = Task.Run(() =>
                    {
                        Console.WriteLine($"Задача {Task.CurrentId} выполняется");
                    });
                }

                Task.WhenAll(tasks).Wait(); // Ожидаем завершения всех задач
            }
        </div>
        <div class="text">
            BlockingCollection&lt;T&gt; — коллекция, которая может быть использована для обмена данными между потоками. Поддерживает блокировку при
            добавлении/удалении элементов, что может быть полезно при реализации моделей producer-consumer.
            ConcurrentBag&lt;T&gt; — потокобезопасная коллекция для хранения объектов, но в отличие от 
            BlockingCollection, она не блокирует потоки. Она использует параллельную обработку элементов, что улучшает производительность.
        </div>
        <div class="code">
            BlockingCollection&lt;int&gt; collection = new BlockingCollection&lt;int&gt;();
            Task producer = Task.Run(() =>
            {
                for (int i = 0; i < 5; i++)
                {
                    collection.Add(i); // Добавляем данные в коллекцию
                    Console.WriteLine($"Производитель добавил {i}");
                }
                collection.CompleteAdding();
            });

            Task consumer = Task.Run(() =>
            {
                foreach (var item in collection.GetConsumingEnumerable())
                {
                    Console.WriteLine($"Потребитель забрал {item}");
                }
            });

            Task.WhenAll(producer, consumer).Wait();
        </div>
        <div class="text">
            Channels в C# — это более новая и эффективная структура для обмена данными между асинхронными задачами.
            Это как буфер для передачи данных между различными потоками.
            Каналы обеспечивают высокоэффективный и удобный способ обмена данными между асинхронными задачами. 
            Channel.CreateUnbounded создаст канал без ограничения размера, а ReadAllAsync() позволяет асинхронно получать данные.
        </div>
        <div class="code">
            public async Task ChannelExample()
            {
                var channel = Channel.CreateUnbounded&lt;int&gt;();

                // Параллельный производитель
                Task producer = Task.Run(async () =>
                {
                    for (int i = 0; i < 5; i++)
                    {
                        await channel.Writer.WriteAsync(i);
                        Console.WriteLine($"Производитель добавил {i}");
                    }
                    channel.Writer.Complete(); // Завершаем запись
                });

                // Параллельный потребитель
                Task consumer = Task.Run(async () =>
                {
                    await foreach (var item in channel.Reader.ReadAllAsync())
                    {
                        Console.WriteLine($"Потребитель забрал {item}");
                    }
                });

                await Task.WhenAll(producer, consumer);
            }
        </div>
        <div class="text">
            В C# сборка мусора (Garbage Collection, GC) — это автоматическая система управления памятью.
            Основная задача GC — отслеживание объектов, которые больше не используются, и освобождение памяти, занятой этими объектами.
            Объекты в памяти: Когда в программе создаются объекты, они размещаются в управляемой памяти (heap).
            Эта память управляется CLR (Common Language Runtime), и когда объект больше не используется, GC очищает память,
            освобождая её для других объектов.<br />
            Три поколения:<br />
            Generation 0 — новые объекты, которые недавно были созданы. Это наименее дорогостоящие объекты в плане сборки мусора.<br />
            Generation 1 — объекты, которые пережили хотя бы одну сборку мусора.<br />
            Generation 2 — объекты, которые живут достаточно долго и требуют очистки реже.<br />
            Цикл сборки мусора: Он проходит несколько этапов, включая:<br />
            Поиск объектов, которые больше не используются.<br />
            Освобождение памяти, занятой этими объектами.<br />
            Сжатие памяти для уплотнения используемой памяти.<br />
            GC сам управляет памятью, но важно понимать, что GC не очищает ресурсы,
            такие как файлы или соединения с базой данных — это нужно делать вручную.<br />
            Weak references — это ссылки на объекты, которые не препятствуют их сборке мусора.
            Они полезны, когда нужно иметь возможность ссылаться на объект, но не хотите, чтобы эта ссылка удерживала объект в памяти.<br />
            Пример использования: Кэширование. Когда объект больше не используется, сборщик мусора может освободить его память, не смотря на
            существование слабой ссылки.<br />
            Особенность: Объект, на который ссылается слабая ссылка, может быть собран сборщиком мусора, даже если на него есть слабая ссылка.<br />
            Для использования слабых ссылок в C# используется класс WeakReference<br />
            В C# важно помнить, что не все ресурсы управляются сборщиком мусора. Например,
            файлы, сокеты и соединения с базой данных требуют явного освобождения ресурсов.
            Для этого используется интерфейс IDisposable.<br />
            IDisposable: Интерфейс, который определяет метод Dispose(),
            предназначенный для освобождения ресурсов. Например, если класс работает с
            внешним ресурсом (файл, соединение), то он должен реализовать IDisposable, чтобы освобождать ресурсы вручную.<br />
            Конструкция using: Она упрощает работу с IDisposable. Этот блок гарантирует, что ресурсы будут освобождены, даже если
            произойдет исключение.

            Span&lt;T&gt; и Memory&lt;T&gt; — это новые структуры данных, введенные в C# 7.2, которые позволяют работать с
            участками памяти без аллокации дополнительных объектов.<br />
            Span&lt;T&gt;: Структура, представляющая непрерывный сегмент памяти. Он предназначен для работы с массивами и срезами.
            Главное преимущество — высокая производительность за счет работы с памятью без аллокаций.<br />
            Memory&lt;T&gt; : Похож на Span&lt;T&gt;, но его можно хранить в переменных и передавать в методы.<br />
            Span&lt;T&gt; нельзя сохранять в поле класса, потому что он является stack-only типом.<br />
            Использование Span&lt;T&gt; особенно полезно в низкоуровневых операциях, например, при манипуляциях с массивами и строками.
        </div>
        <div class="code">
            using (var resource = new SomeResource())
            {
                // Работа с ресурсом
            }
            // Когда блок using завершится, метод Dispose() будет вызван автоматически.
        </div>
    </main>

</body>
</html>

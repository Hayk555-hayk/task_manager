<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЗАДАЧИ</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <main>
        <div class="text">
            <h3>C#</h3>
            Программа на C# состоит из классов и методов. Главный метод программы называется Main.
            Это точка входа, с которой начинается выполнение программы.
        </div>
        <div class="code">
            using System; // Подключение пространства имен для работы с консолью

            class Program // Объявление класса
            {
                static void Main() // Главный метод программы
                {
                Console.WriteLine("Hello, World!"); // Вывод текста в консоль
                }
            }

            int number = 10; // Целое число
            double pi = 3.14; // Число с плавающей точкой
            char letter = 'A'; // Символ
            string name = "Alice"; // Строка
            bool isActive = true; // Логический тип (true или false)
        </div>
        <div class="text">
            using System; — подключение пространства имен System, которое содержит стандартные классы, например, для работы с консолью.<br />
            class Program — определение класса Program.<br />
            static void Main() — метод Main, который будет выполнен при запуске программы. Он должен быть статическим,
            потому что вызывается без создания экземпляра класса.<br />
            Console.WriteLine("Hello, World!"); — команда, которая выводит строку на экран.<br />
            Для управления потоком программы в C# используются условные операторы и циклы.<br />
        </div>
        <div class="code">
            if (a > b)
            {
                Console.WriteLine("a больше b");
            }
            else
            {
                Console.WriteLine("a меньше или равно b");
            }

            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine(i); // Выводит числа от 0 до 4
            }

            int counter = 0;
            while (counter < 5)
            {
                Console.WriteLine(counter);
                counter++;
            }
        </div>
        <div class="text">
            Методы — это блоки кода, которые можно вызвать для выполнения определенной задачи.
        </div>
        <div class="code">
            class Program
            {
                static void Main()
                {
                    GreetUser("Alice"); // Вызов метода
                }

                static void GreetUser(string name)
                {
                    Console.WriteLine($"Hello, {name}!");
                }
            }
        </div>
        <div class="text">
            Класс — это шаблон для создания объектов. Он объединяет данные (поля) и методы (функции, работающие с этими данными).
        </div>
        <div class="code">
            class Person
            {
                // Поля (переменные внутри класса)
                public string Name;
                public int Age;

                // Метод (функция, связанная с объектом)
                public void Introduce()
                {
                    Console.WriteLine($"Привет! Меня зовут {Name}, мне {Age} лет.");
                }
            }
            --------------------------------------------------------------
            using System;

            class Program
            {
                static void Main()
                {
                    // Создаем объект класса Person
                    Person person1 = new Person();
                    person1.Name = "Айк";
                    person1.Age = 31;

                    person1.Introduce(); // Вызываем метод объекта
                }
            }
        </div>
        <div class="text">
            Вместо того чтобы заполнять поля вручную, можно использовать конструктор:
            Конструкторы можно перегружать - создавать несколько конструкторов с разными количествами аргументов 
        </div>
        <div class="code">
            class Person
            {
                public string Name;
                public int Age;

                // Конструктор
                public Person(string name, int age)
                {
                    Name = name;
                    Age = age;
                }

                public void Introduce()
                {
                    Console.WriteLine($"Привет! Меня зовут {Name}, мне {Age} лет.");
                }
            }
        </div>
        <div class="text">
            Свойства позволяют контролировать доступ к данным внутри класса:
        </div>
        <div class="code">
            class Person
            {
                public string Name { get; set; } // Автосвойство
                private int _age; // Приватное поле

                public int Age
                {
                    get { return _age; }
                    set
                    {
                        if (value < 0) 
                            throw new ArgumentException("Возраст не может быть отрицательным!");
                        _age = value;
                    }
                }

                public Person(string name, int age)
                {
                    Name = name;
                    Age = age;
                }

                public void Introduce()
                {
                    Console.WriteLine($"Привет! Меня зовут {Name}, мне {Age} лет.");
                }
            }
        </div>
        <div class="text">
            Структуры похожи на классы, но используются для простых объектов (например, координаты точки).
            Отличие struct от class:
            struct хранится в стеке, а class — в куче (heap).
            struct передается по значению, а class — по ссылке.
            struct не поддерживает наследование.
            DateTime это Strict.
        </div>
        <div class="code">
            struct Point
            {
                public int X;
                public int Y;

                public Point(int x, int y)
                {
                    X = x;
                    Y = y;
                }

                public void Print()
                {
                    Console.WriteLine($"Точка: ({X}, {Y})");
                }
            }
        </div>
        <div class="text">
            Интерфейс определяет контракт (какие методы должен реализовать класс), но не содержит их реализацию.
            Преимущества интерфейсов:
            Позволяют гибко строить архитектуру.
            Используются для полиморфизма.
            Применяются в Dependency Injection
        </div>
        <div class="code">
            interface IMovable
            {
                void Move(int distance);
            }

            class Car : IMovable
            {
                public string Model { get; set; }

                public Car(string model)
                {
                    Model = model;
                }

                public void Move(int distance)
                {
                    Console.WriteLine($"{Model} проехал {distance} км.");
                }
            }
        </div>
        <div class="text">
            Объектно-ориентированное программирование — это парадигма программирования, которая организует код вокруг объектов и данных, а не действий и логики.
            Это позволяет создать структуру программы, которая легче поддерживается и расширяется. 
            Основные концепты ООП включают:<br />
            Инкапсуляция — это принцип, при котором данные (поля) и методы (функции), которые с ними работают, объединяются в одном объекте. 
            Это позволяет скрыть детали реализации и показать только нужные интерфейсы.
            Пример: в классе "Автомобиль" можно инкапсулировать данные о марке, модели, скорости, а методы будут отвечать за управление этими данными, 
            например, "Ускорить", "Тормозить".<br />
            Наследование — это механизм, который позволяет создавать новый класс на основе существующего, что позволяет повторно использовать 
            код и создавать иерархию классов.
            Пример: класс "Мотоцикл" может наследовать от класса "Транспортное средство", добавляя свои уникальные характеристики и поведение.<br />
            Полиморфизм — это способность объектов разных типов реагировать на одни и те же сообщения (методы) по-разному.
            Пример: метод "Звук" может работать по-разному в классе "Автомобиль" и в классе "Мотоцикл". В первом случае это будет звук двигателя, а во втором — звук работы мотора.
        </div>
        <div class="text">
            .NET Framework — это платформа, предназначенная для разработки приложений, в основном для Windows.
            Она существует с 2002 года и включает в себя: <br />
            CLR (Common Language Runtime) — среда выполнения, которая управляет выполнением кода. <br />
            BCL (Base Class Library) — набор стандартных библиотек для разработки приложений. <br />
            Программы на .NET Framework ограничены Windows, то есть они не могут быть легко перенесены на другие операционные системы. <br />

            .NET Core — это кросс-платформенная версия .NET Framework, которая была представлена в 2016 году.
            Она решает проблему совместимости и открывает путь для разработки приложений, которые могут работать на Windows, Linux и macOS.
            Основные особенности: <br />
            Кросс-платформенность: можно разрабатывать и запускать приложения на различных операционных системах.<br />
            Модульность: можно подключать только те библиотеки, которые нужны в проекте.<br />
            Прозрачность: проект был с открытым исходным кодом с самого начала.<br />
            ASP.NET Core: это платформа для разработки веб-приложений, которая также была выпущена как часть .NET Core.<br />

            .NET 5 и последующие версии (.NET 6/7/8) <br />
            С 2020 года Microsoft объединяет .NET Core и .NET Framework в одну платформу, начиная с версии .NET 5.
            Это решение позволяет упростить экосистему, и теперь вся платформа называется просто .NET.
            Следующие версии — .NET 6, .NET 7, .NET 8 — являются развитием этой единой платформы.<br />
            Кросс-платформенность: начиная с .NET 5, разработка приложений поддерживает Windows, Linux и macOS, а также мобильные и
            облачные платформы.<br />
            Поддержка долгосрочной стабильности: .NET 6, например, является LTS-версией (Long Term Support), что
            означает долгосрочную поддержку для стабильных приложений.<br />
            Поддержка новых технологий: .NET 6/7/8 имеют улучшения в производительности, оптимизацию работы с памятью и поддержку
            современных технологий, таких как контейнеризация и микросервисы.<br />
            С 2020 года Microsoft объединяет .NET Core и .NET Framework в одну платформу, начиная с версии .NET 5. 
            Это решение позволяет упростить экосистему, и теперь вся платформа называется просто .NET. Следующие версии — .NET 6, 
            .NET 7, .NET 8 — являются развитием этой единой платформы.<br />
            Кросс-платформенность: начиная с .NET 5, разработка приложений поддерживает Windows, 
            Linux и macOS, а также мобильные и облачные платформы.<br />
            Поддержка долгосрочной стабильности: .NET 6, например, является LTS-версией (Long Term Support), что означает долгосрочную поддержку для 
            стабильных приложений.<br />
            Поддержка новых технологий: .NET 6/7/8 имеют улучшения в производительности, оптимизацию работы с памятью и поддержку современных технологий,
            таких как контейнеризация и микросервисы.<br />
            Основные отличия:<br />
            .NET Framework — работает только на Windows.<br />
            .NET Core — кросс-платформенный, но поддерживает меньше технологий и фреймворков.<br />
            .NET (после .NET 5) — объединение всех платформ в одну с кросс-платформенностью и современными улучшениями.
        </div>
        <div class="text">
            Асинхронность позволяет выполнять операции без блокировки потока, что важно для повышения производительности и отклика в приложениях,
            особенно в многозадачных или I/O-ориентированных системах.<br />
            async — это модификатор, который применяется к методу. Он указывает, что метод будет выполняться асинхронно.<br />
            await — используется внутри асинхронного метода для приостановки выполнения, ожидая завершения асинхронной операции.
            Когда операция завершена, выполнение метода продолжается.<br />
            Task — представляет собой операцию, которая будет завершена в будущем. Возвращаемое значение Task или Task&lt;T&gt;<br />
            (если возвращаемое значение метода не void) указывает на задачу, которая будет выполнена асинхронно.<br />
            Когда метод помечен как async, он возвращает Task (или Task&lt;T&gt;, если возвращаемое значение метода имеет тип). <br />
            Если метод не возвращает ничего (т.е. void), он все равно должен быть асинхронным, но его использование ограничено.
        </div>
        <div class="code">
            public async Task&lt;string&gt; GetDataAsync()
            {
            // Имитируем асинхронную операцию (например, HTTP-запрос)
            await Task.Delay(2000);  // Ожидаем 2 секунды без блокировки потока
            return "Данные получены";
            }
        </div>
        <div class="text">
            Task Parallel Library — это мощный инструмент для работы с многозадачностью в C#.
            Он предоставляет возможность создавать и управлять задачами параллельно. Это особенно полезно для выполнения операций в фоновом режиме,
            таких как вычисления или операции ввода/вывода.<br />
            Основные методы TPL:<br />
            Task.Run — создает задачу, которая будет выполнена в пуле потоков.<br />
            Task.WhenAll — позволяет ожидать завершения нескольких задач.<br />
            Task.WhenAny — ожидает завершения первой из нескольких задач.<br />
        </div>
        <div class="code">
            public void ParallelTaskExample()
            {
                Task[] tasks = new Task[3];
                for (int i = 0; i < 3; i++)
                {
                    tasks[i] = Task.Run(() =>
                    {
                        Console.WriteLine($"Задача {Task.CurrentId} выполняется");
                    });
                }

                Task.WhenAll(tasks).Wait(); // Ожидаем завершения всех задач
            }
        </div>
        <div class="text">
            BlockingCollection&lt;T&gt; — коллекция, которая может быть использована для обмена данными между потоками. Поддерживает блокировку при
            добавлении/удалении элементов, что может быть полезно при реализации моделей producer-consumer.
            ConcurrentBag&lt;T&gt; — потокобезопасная коллекция для хранения объектов, но в отличие от 
            BlockingCollection, она не блокирует потоки. Она использует параллельную обработку элементов, что улучшает производительность.
        </div>
        <div class="code">
            BlockingCollection&lt;int&gt; collection = new BlockingCollection&lt;int&gt;();
            Task producer = Task.Run(() =>
            {
                for (int i = 0; i < 5; i++)
                {
                    collection.Add(i); // Добавляем данные в коллекцию
                    Console.WriteLine($"Производитель добавил {i}");
                }
                collection.CompleteAdding();
            });

            Task consumer = Task.Run(() =>
            {
                foreach (var item in collection.GetConsumingEnumerable())
                {
                    Console.WriteLine($"Потребитель забрал {item}");
                }
            });

            Task.WhenAll(producer, consumer).Wait();
        </div>
        <div class="text">
            Channels в C# — это более новая и эффективная структура для обмена данными между асинхронными задачами.
            Это как буфер для передачи данных между различными потоками.
            Каналы обеспечивают высокоэффективный и удобный способ обмена данными между асинхронными задачами. 
            Channel.CreateUnbounded создаст канал без ограничения размера, а ReadAllAsync() позволяет асинхронно получать данные.
        </div>
        <div class="code">
            public async Task ChannelExample()
            {
                var channel = Channel.CreateUnbounded&lt;int&gt;();

                // Параллельный производитель
                Task producer = Task.Run(async () =>
                {
                    for (int i = 0; i < 5; i++)
                    {
                        await channel.Writer.WriteAsync(i);
                        Console.WriteLine($"Производитель добавил {i}");
                    }
                    channel.Writer.Complete(); // Завершаем запись
                });

                // Параллельный потребитель
                Task consumer = Task.Run(async () =>
                {
                    await foreach (var item in channel.Reader.ReadAllAsync())
                    {
                        Console.WriteLine($"Потребитель забрал {item}");
                    }
                });

                await Task.WhenAll(producer, consumer);
            }
        </div>
        <div class="text">
            В C# сборка мусора (Garbage Collection, GC) — это автоматическая система управления памятью.
            Основная задача GC — отслеживание объектов, которые больше не используются, и освобождение памяти, занятой этими объектами.
            Объекты в памяти: Когда в программе создаются объекты, они размещаются в управляемой памяти (heap).
            Эта память управляется CLR (Common Language Runtime), и когда объект больше не используется, GC очищает память,
            освобождая её для других объектов.<br />
            Три поколения:<br />
            Generation 0 — новые объекты, которые недавно были созданы. Это наименее дорогостоящие объекты в плане сборки мусора.<br />
            Generation 1 — объекты, которые пережили хотя бы одну сборку мусора.<br />
            Generation 2 — объекты, которые живут достаточно долго и требуют очистки реже.<br />
            Цикл сборки мусора: Он проходит несколько этапов, включая:<br />
            Поиск объектов, которые больше не используются.<br />
            Освобождение памяти, занятой этими объектами.<br />
            Сжатие памяти для уплотнения используемой памяти.<br />
            GC сам управляет памятью, но важно понимать, что GC не очищает ресурсы,
            такие как файлы или соединения с базой данных — это нужно делать вручную.<br />
            Weak references — это ссылки на объекты, которые не препятствуют их сборке мусора.
            Они полезны, когда нужно иметь возможность ссылаться на объект, но не хотите, чтобы эта ссылка удерживала объект в памяти.<br />
            Пример использования: Кэширование. Когда объект больше не используется, сборщик мусора может освободить его память, не смотря на
            существование слабой ссылки.<br />
            Особенность: Объект, на который ссылается слабая ссылка, может быть собран сборщиком мусора, даже если на него есть слабая ссылка.<br />
            Для использования слабых ссылок в C# используется класс WeakReference<br />
            В C# важно помнить, что не все ресурсы управляются сборщиком мусора. Например,
            файлы, сокеты и соединения с базой данных требуют явного освобождения ресурсов.
            Для этого используется интерфейс IDisposable.<br />
            IDisposable: Интерфейс, который определяет метод Dispose(),
            предназначенный для освобождения ресурсов. Например, если класс работает с
            внешним ресурсом (файл, соединение), то он должен реализовать IDisposable, чтобы освобождать ресурсы вручную.<br />
            Конструкция using: Она упрощает работу с IDisposable. Этот блок гарантирует, что ресурсы будут освобождены, даже если
            произойдет исключение.

            Span&lt;T&gt; и Memory&lt;T&gt; — это новые структуры данных, введенные в C# 7.2, которые позволяют работать с
            участками памяти без аллокации дополнительных объектов.<br />
            Span&lt;T&gt;: Структура, представляющая непрерывный сегмент памяти. Он предназначен для работы с массивами и срезами.
            Главное преимущество — высокая производительность за счет работы с памятью без аллокаций.<br />
            Memory&lt;T&gt; : Похож на Span&lt;T&gt;, но его можно хранить в переменных и передавать в методы.<br />
            Span&lt;T&gt; нельзя сохранять в поле класса, потому что он является stack-only типом.<br />
            Использование Span&lt;T&gt; особенно полезно в низкоуровневых операциях, например, при манипуляциях с массивами и строками.
        </div>
        <div class="code">
            using (var resource = new SomeResource())
            {
                // Работа с ресурсом
            }
            // Когда блок using завершится, метод Dispose() будет вызван автоматически.
        </div>
        <div class="text">
            <h3>WEB DEVELOPMENT</h3>
            <h4>PHP</h4>
            PHP (Hypertext Preprocessor) — это язык серверного программирования, который широко используется для создания динамических веб-сайтов
            и веб-приложений. PHP выполняется на сервере и генерирует HTML-код, который отправляется в браузер пользователя.<br />
            Основные особенности PHP:<br />
            Интерпретируемый язык, выполняемый на сервере.<br />
            Поддержка множества баз данных (MySQL, PostgreSQL, SQLite и др.).<br />
            Гибкость и простота интеграции с HTML.<br />
            Богатый набор встроенных функций.<br />
            Поддержка объектно-ориентированного программирования (ООП).<br />
            Клиент отправляет HTTP-запрос (обычно через браузер).<br />
            Сервер (Apache, Nginx) принимает запрос и передает его в интерпретатор PHP.<br />
            PHP выполняет код, взаимодействует с базами данных и возвращает HTML-код.<br />
            Сервер отправляет HTML-код обратно клиенту.<br />
            <h4>LARAVEL</h4>
            Laravel — это популярный PHP-фреймворк для разработки веб-приложений, который использует
            архитектурный шаблон MVC (Model-View-Controller).<br />
            Основные преимущества Laravel:<br />
            Чистый и понятный синтаксис.<br />
            Встроенная поддержка аутентификации и авторизации.<br />
            Элегантный механизм маршрутизации.<br />
            ORM Eloquent для работы с базами данных.<br />
            Поддержка кэширования, очередей, событий и других механизмов.<br />
            Входящий запрос проходит через public/index.php.<br />
            Laravel инициализирует свой сервис-контейнер и сервис-провайдеры.<br />
            Запрос передается в маршрутизатор (routes/web.php).<br />
            Контроллер обрабатывает запрос и возвращает ответ (обычно представление или JSON).<br />
            <h4>GO</h4>
            Go — это компилируемый многопоточный язык программирования, разработанный Google, который
            обладает высокой производительностью и простотой синтаксиса.<br />
            Высокая скорость выполнения (почти как у C).<br />
            Сильная типизация.<br />
            Поддержка конкурентного программирования (goroutines).<br />
            Встроенные инструменты для тестирования и сборки кода.<br />
        </div>
        <div class="code">
            package main
            import "fmt"

            func main() {
                fmt.Println("Hello, World!")
            }
        </div>
        <div class="text">
            <h4>JAVASCRIPT</h4>
            JavaScript — это язык программирования, который выполняется в браузере и делает веб-страницы динамичными.<br />
            Основные возможности JavaScript:<br />
            Работа с DOM (изменение HTML и CSS на лету).<br />
            Асинхронное программирование с Promise и async/await.<br />
            Поддержка модулей и ES6+.<br />
            Взаимодействие с API и веб-серверами.<br />
            <h4>NODE JS</h4>
            Node.js — это среда выполнения JavaScript на сервере, позволяющая создавать веб-приложения, работающие без браузера.<br />
            Основные преимущества:<br />
            Асинхронная, событийно-ориентированная модель.<br />
            Высокая производительность благодаря движку V8.<br />
            Большая экосистема пакетов (npm).<br />
        </div>
        <div class="code">
            const http = require('http');

            const server = http.createServer((req, res) => {
                res.writeHead(200, { 'Content-Type': 'text/plain' });
                res.end('Hello, World!');
            });

            server.listen(3000, () => console.log('Server running on port 3000'));
        </div>
        <div class="text">
            <h4>EXPRESS JS</h4>
            Express.js — это минималистичный фреймворк для Node.js, который упрощает создание серверных приложений.
        </div>
        <div class="code">
            const express = require('express');
            const app = express();

            app.get('/hello', (req, res) => {
                res.send('Hello, World!');
            });

            app.listen(3000, () => console.log('Server is running on port 3000'));
        </div>
        <div class="text">
            <h4>NEST JS</h4>
            Nest.js — это фреймворк для Node.js, построенный на TypeScript и основанный на принципах ООП и модульности.
        </div>
        <div class="code">
            import { Controller, Get } from '@nestjs/common';

            @Controller('hello')
            export class HelloController {
              @Get()
              getHello(): string {
                return 'Hello, World!';
              }
            }
        </div>
        <div class="text">
            <h4>ANGULAR JS</h4>
            AngularJS — это фреймворк для фронтенд-разработки от Google, который позволяет создавать динамичные веб-приложения.
        </div>
        <div class="code">
            import { Component } from '@angular/core';

            @Component({
            selector: 'app-hello',
            template: '&lt;h1&gt;Hello, World!&lt;/h1&gt;'
            })
            export class HelloComponent {}
        </div>
        <div class="text">
            <h4>REACT JS</h4>
            React.js — это библиотека для создания пользовательских интерфейсов от Facebook, использующая виртуальный DOM для высокой производительности.
        </div>
        <div class="code">
            import React from 'react';

            function Hello() {
                return &lt;h1&gt;Hello, World!&lt;/h1&gt;;
            }

            export default Hello;
        </div>
        <div class="text">
            <h4>PHP</h4>
            PHP — это интерпретируемый язык, но его код сначала компилируется в промежуточное представление (опкоды), которое затем выполняется Zend Engine.<br />
            Работа интерпретатора PHP <br />
            PHP-код загружается в интерпретатор<br />
            Парсер анализирует синтаксис и создает AST (Abstract Syntax Tree)<br />
            Компилятор превращает AST в опкоды (bytecode)<br />
            Zend Engine выполняет опкоды<br />
            Результат возвращается клиенту<br />
            Встроенные структуры данных <br />
            PHP предоставляет несколько типов структур данных:<br />
            Массивы (array) — ассоциативные массивы (реализованы через хеш-таблицы)<br />
            Объекты (object) — экземпляры классов<br />
            Ресурсы (resource) — ссылки на внешние объекты (файлы, сокеты, базы данных)<br />
            NULL — специальное значение для отсутствующих переменных<br />
            PHP поддерживает полное объектно-ориентированное программирование, включая инкапсуляцию, наследование и полиморфизм.
        </div>
        <div class="code">
            class User {
                private string $name;
    
                public function __construct(string $name) {
                    $this->name = $name;
                }
    
                public function getName(): string {
                    return $this->name;
                }
            }

            $user = new User("Айк");
            echo $user->getName(); // Айк
        </div>
        <div class="text">
            Работа с памятью в PHP <br />
            PHP использует автоматический Garbage Collector (GC) для очистки памяти. Основные механизмы управления памятью:<br />
            Счетчик ссылок (Reference Counting)<br />
            Сборщик мусора (Garbage Collector)<br />
            Ручное управление памятью (unset(), gc_collect_cycles())
        </div>
        <div class="code">
            $obj = new stdClass();
            $obj2 = $obj;
            unset($obj);
            gc_collect_cycles(); // Принудительный запуск GC
        </div>
        <div class="text">
            <h4>LARAVEL</h4>
            Laravel построен на архитектуре MVC (Model-View-Controller).<br />
            Структура проекта<br />
            Основные директории Laravel:<br />
            app/ — логика приложения (модели, контроллеры, сервисы)<br />
            routes/ — маршрутизация (web.php, api.php)<br />
            resources/views/ — шаблоны Blade<br />
            database/ — миграции и seeders<br />
            config/ — конфигурационные файлы<br />
            Работа маршрутизации<br />
            Laravel использует мощную систему маршрутизации, позволяя легко управлять входящими запросами.<br />
            Пример маршрута в routes/web.php
        </div>
        <div class="code">
            Route::get('/hello/{name}', function ($name) {
                return "Привет, $name!";
            });
        </div>
        <div class="text">
            В Laravel контроллеры управляют бизнес-логикой. Пример контроллера:
        </div>
        <div class="code">
            use Illuminate\Http\Request;
            use App\Http\Controllers\Controller;

            class UserController extends Controller {
                public function show($id) {
                    return "User ID: " . $id;
                }
            }
        </div>
        <div class="text">
            Eloquent — это мощный ORM, который позволяет работать с базами данных как с объектами.
        </div>
        <div class="code">
            use Illuminate\Database\Eloquent\Model;

            class User extends Model {
                protected $fillable = ['name', 'email'];
            }

            // Пример получения данных из базы:
            $user = User::find(1);
            echo $user->name;
        </div>
        <div class="text">
            <h4>GO</h4>
            Go использует систему компиляции и выполнения кода, которая сочетает статическую типизацию и сборку мусора.<br />
            Основные компоненты Go:<br />
            Go runtime — отвечает за выполнение кода, управление памятью и многопоточность.<br />
            Goroutines — легковесные потоки, которые позволяют писать асинхронный код.<br />
            Горутины позволяют писать асинхронный код без сложных потоков.
        </div>
        <div class="code">
            package main

            import (
                "fmt"
                "time"
            )

            func hello() {
                fmt.Println("Hello from Goroutine")
            }

            func main() {
                go hello()
                time.Sleep(time.Second) // Ждем выполнения горутины
            }
        </div>
        <div class="text">
            <h4>JAVASCRIPT</h4>
            JavaScript использует event loop для обработки асинхронных задач.
        </div>
        <div class="code">
            console.log("Start");

            setTimeout(() => {
                console.log("Timeout executed");
            }, 0);

            console.log("End");

            // Start
            // End
            // Timeout executed
        </div>
        <div class="text">
            <h4>NODE JS</h4>
            Node.js работает по событийно-ориентированной модели, используя libuv для работы с потоками.
        </div>
        <div class="code">
            const fs = require('fs');

            fs.readFile('file.txt', 'utf8', (err, data) => {
                if (err) throw err;
                console.log(data);
            });
        </div>
        <div class="text">
            <h4>EXPRESS JS</h4>
            Middleware (промежуточное ПО) — это функции, которые выполняются между получением запроса и отправкой ответа.
        </div>
        <div class="code">
            const express = require('express');
            const app = express();

            app.use((req, res, next) => {
                console.log(`Request: ${req.method} ${req.url}`);
                next();
            });

            app.get('/', (req, res) => {
                res.send('Hello, World!');
            });

            app.listen(3000, () => console.log('Server running on port 3000'));
        </div>
        <div class="text">
            <h4>NEST JS</h4>
            Nest.js использует сервисы для работы с бизнес-логикой.
        </div>
        <div class="code">
            import { Injectable } from '@nestjs/common';

            @Injectable()
            export class UserService {
              getUser() {
                return { id: 1, name: "Айк" };
              }
            }
        </div>
        <div class="text">
            <h4>ANGULAR JS</h4>
            AngularJS использует директивы для работы с DOM.
        </div>
        <div class="code">
            //HTML
            &lt;div ng-app="myApp" ng-controller="myCtrl"&gt;
            &lt;p&gt;{{ message }}&lt;/p&gt;
            &lt;/div&gt;

            //JS
            angular.module('myApp', []).controller('myCtrl', function($scope) {
                $scope.message = "Привет, мир!";
            });
        </div>
        <div class="text">
            <h4>REACT JS</h4>
            React использует хуки (useState, useEffect) для управления состоянием.
        </div>
        <div class="code">
            import React, { useState } from 'react';

            function Counter() {
                const [count, setCount] = useState(0);

                return (
                    &lt;div&gt;
                        &lt;p&gt;Счетчик: {count}&lt;/p&gt;
                        &lt;button onClick={() => setCount(count + 1)}&gt;+&lt;/button&gt;
                    &lt;/div&gt;
                );
            }

            export default Counter;
        </div>
        <div class="text">
            <h4>PHP</h4>
            Оптимизация работы с памятью <br />
            Использование unset($var) для освобождения памяти.<br />
            Использование gc_collect_cycles() для ручного запуска сборщика мусора.<br />
            Использование spl_fixedarray вместо обычных массивов для экономии памяти.<br />
            Кэширование<br />
            OPcache: ускоряет работу за счет хранения байт-кода.<br />
            APCu: кэширует данные в памяти.<br />
            Пример включения OPcache:<br />
        </div>
        <div class="code">
            opcache.enable=1
            opcache.memory_consumption=128
            opcache.max_accelerated_files=10000
            opcache.validate_timestamps=0
        </div>
        <div class="text">
            Снижение количества SQL-запросов <br />
            Использование JOIN вместо нескольких запросов.<br />
            Кэширование данных (Redis, Memcached).<br />
            <h4>LARAVEL</h4>
            Service Container позволяет автоматически внедрять зависимости
        </div>
        <div class="code">
            class PaymentService {
            public function pay() {
                return "Оплата проведена!";
            }
        }

        // В сервис-провайдере
        app()->bind('PaymentService', function() {
            return new PaymentService();
        });

        // Использование
        $payment = app('PaymentService');
        echo $payment->pay();
        </div>
        <div class="text">
            Middleware используются для фильтрации запросов.
        </div>
        <div class="code">
            public function handle($request, Closure $next) {
                if (!$request->has('token')) {
                    return response('Access denied', 403);
                }
                return $next($request);
            }
        </div>
        <div class="text">
            <h4>GO</h4>
            Каналы позволяют безопасно передавать данные между горутинами.
        </div>
        <div class="code">
            package main

            import "fmt"

            func main() {
                messages := make(chan string)

                go func() { messages &lt;- "Hello from Goroutine" }()

                msg := &lt;-messages
                fmt.Println(msg)
            }
        </div>
        <div class="text">
            Буферизированные каналы позволяют отправлять несколько сообщений без немедленного чтения.
        </div>
        <div class="code">
            ch := make(chan int, 2)
            ch &lt;- 1
            ch &lt;- 2
            fmt.Println(&lt;-ch)
            fmt.Println(&lt;-ch)
        </div>
        <div class="text">
            <h4>JAVASCRIPT</h4>
            Microtasks (Promise callbacks) выполняются до следующего рендера, а Macrotasks (setTimeout) — после.
        </div>
        <div class="code">
            console.log("Start");
            setTimeout(() => console.log("Timeout"), 0);
            Promise.resolve().then(() => console.log("Promise"));
            console.log("End");

            // Start
            // End
            // Promise
            // Timeout
        </div>
        <div class="text">
            <h4>NODE JS</h4>
            Потоки позволяют запускать код параллельно.
        </div>
        <div class="code">
            const { Worker } = require('worker_threads');

            const worker = new Worker(`
                parentPort.on('message', msg => {
                    parentPort.postMessage(msg * 2);
                });
            `, { eval: true });

            worker.on('message', msg => console.log(`Received: ${msg}`));
            worker.postMessage(10);
        </div>
        <div class="text">
            <h4>EXPRESS JS</h4>
            Async/Await в Express
        </div>
        <div class="code">
            app.get('/data', async (req, res) => {
                const data = await fetchData();
                res.json(data);
            });
        </div>
        <div class="text">
            <h4>NEST JS</h4>
            Nest.js — Dependency Injection
        </div>
        <div class="code">
            @Injectable()
            export class AuthService {
              constructor(private readonly userService: UserService) {}

              validateUser(email: string, password: string): boolean {
                return this.userService.findUser(email)?.password === password;
              }
            }
        </div>
        <div class="text">
            <h4>ANGULAR JS</h4>
            Динамические компоненты
        </div>
        <div class="code">
            // HTML
            &lt;div ng-controller="MyController"&gt;
                &lt;p&gt;{{ message }}&lt;/p&gt;
            &lt;/div&gt;

            // JS
            angular.module('app', []).controller('MyController', function($scope) {
                $scope.message = "Hello, AngularJS!";
            });
        </div>
        <div class="text">
            <h4>REACT JS</h4>
            Использование useMemo и useCallback для оптимизации рендеринга.
        </div>
        <div class="code">
            const expensiveCalculation = useMemo(() => computeExpensiveValue(data), [data]);
        </div>
    </main>

</body>
</html>

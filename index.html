<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЗАДАЧИ</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <main>
        <div class="text">
            <h3>C#</h3>
            <h4>ОСНОВЫ ЯЗЫКА C# (урок 1)</h4>
            C# — это современный, объектно-ориентированный язык программирования, разработанный Microsoft. Он используется для: <br />
            Создания desktop-приложений (Windows Forms, WPF)<br />
            Веб-разработки (ASP.NET, Blazor)<br />
            Мобильных приложений (Xamarin, MAUI)<br />
            Игр (Unity)<br />
            Серверных приложений (Microservices, API)<br />
        </div>
        <div class="code">
            // Program.cs точка входа программы
            // Это комментарий — он не влияет на код
            using System; // Подключение пространства имён System

            class Program // Объявление класса Program
            {
                static void Main(string[] args) // Главный метод программы
                {
                    Console.WriteLine("Hello, World!"); // Вывод текста в консоль
                }
            }
        </div>
        <div class="text">
            Переменная — это именованная область памяти, которая хранит данные. У каждой переменной есть: <br />
            Имя (например, age, name)<br />
            Тип данных (например, число, текст)<br />
            Значение (например, 25, "Анна")<br />
            Основные типы данных<br />
            int	10, -5	Целое число<br />
            double	3.14, -0.5	Число с плавающей точкой<br />
            bool	true, false	Логический тип (истина/ложь)<br />
            char	'A', 'ж'	Один символ<br />
            string	"Привет"	Строка (текст)<br />
            const double PI = 3.14159; - Используйте const, если значение не должно меняться
        </div>
        <div class="code">
            int age = 25;                  // Целое число
            double height = 1.75;          // Число с плавающей точкой
            string name = "Иван";          // Строка
            bool isStudent = true;         // Логическое значение
            char grade = 'A';              // Один символ
        </div>
        <div class="text">
            В C# для чтения ввода с клавиатуры используется метод Console.ReadLine() <br />
            Convert.ToInt32()	int age = Convert.ToInt32("25");	Преобразует строку в целое число. Если строка не число — ошибка.<br />
            int.Parse()	int num = int.Parse("10");	Аналогично Convert, но менее гибкий.<br />
            int.TryParse()	int.TryParse("abc", out _)	Безопасный метод. Возвращает true/false в зависимости от успеха.<br />
        </div>
        <div class="code">
            Console.Write("Введите ваше имя: ");  // Вывод подсказки (без перевода строки)
            string userName = Console.ReadLine();  // Чтение ввода

            Console.WriteLine($"Привет, {userName}!");

            -----------------------------------------------------

            Console.Write("Сколько вам лет? ");
            string input = Console.ReadLine();  // Пользователь вводит "30" (но это всё ещё строка!)
            int age = Convert.ToInt32(input);   // Преобразуем строку в число

            Console.WriteLine($"Через 10 лет вам будет {age + 10}");  // Можно делать вычисления!

            -----------------------------------------------------

            Console.Write("Введите число: ");
            string input = Console.ReadLine();
            int number;

            if (int.TryParse(input, out number))  // Если преобразование удалось
            {
                Console.WriteLine($"Вы ввели: {number}");
            }
            else  // Если ввели не число
            {
                Console.WriteLine("Ошибка: это не число!");
            }
        </div>
        <div class="text">
            Конструкции if/else if/else, switch/case/break/default
        </div>
        <div class="code">
            if (number > 0) 
            {
                Console.WriteLine("Положительное!");
            } 
            else if (number < 0) 
            {
                Console.WriteLine("Отрицательное!");
            } 
            else 
            {
                Console.WriteLine("Это ноль!");
            }

            ------------------------------------

            Console.Write("Введите цифру от 1 до 3: ");
            int digit = Convert.ToInt32(Console.ReadLine());

            switch (digit) 
            {
                case 1:
                    Console.WriteLine("Вы выбрали 1");
                    break;
                case 2:
                    Console.WriteLine("Вы выбрали 2");
                    break;
                case 3:
                    Console.WriteLine("Вы выбрали 3");
                    break;
                default:
                    Console.WriteLine("Неизвестная цифра");
                    break;
            }
        </div>
        <div class="text">
            <h4>ПЛАТФОРМА .NET (урок 2)</h4>
            .NET — это кроссплатформенная платформа для разработки приложений, созданная Microsoft. Она включает: <br />
            Языки программирования (C#, F#, VB.NET)<br />
            Библиотеки классов (готовые компоненты для работы с файлами, сетью, базами данных и т. д.)<br />
            Среды выполнения (CLR — Common Language Runtime)<br />
            Поддерживает:<br />
            Windows, Linux, macOS<br />
            Веб, мобильные, десктоп, игры, IoT, AI<br />
            Основные компоненты .NET<br />
            CLR (Common Language Runtime) – исполняет код, управляет памятью, безопасностью.<br />
            FCL (Framework Class Library) – стандартные библиотеки для работы с коллекциями, файлами, сетью и т. д.<br />
            Roslyn – компилятор C#.<br />
            ASP.NET Core – фреймворк для веб-приложений.<br />
            Entity Framework – ORM для работы с базами данных.<br />
            .NET vs .NET Core vs .NET Framework<br />
            .NET Framework – старая версия (только Windows).<br />
            .NET Core – кроссплатформенный преемник (2016).<br />
            .NET 5+ – единая платформа (с 2020, объединила Core и Framework).<br />
            Как работает .NET?<br />
            Вы пишете код на C#.<br />
            Компилятор превращает его в CIL (Common Intermediate Language).<br />
            CLR компилирует CIL в машинный код (JIT-компиляция).<br />
            Приложение выполняется.<br />
            В папке MyApp появились файлы:<br />
            Program.cs — основной файл с кодом.<br />
            MyApp.csproj — конфигурация проекта (зависимости, версия .NET).<br />
            dotnet new	Создаёт новый проект<br />
            dotnet run	Запускает приложение<br />
            dotnet build	Компилирует проект<br />
            dotnet restore	Восстанавливает зависимости<br />
            <h4>ООП в C# (урок 3)</h4>
            ООП — это методология программирования, основанная на использовании объектов и классов.<br />
            Основные принципы ООП:<br />
            Инкапсуляция — скрытие внутренней реализации.<br />
            Наследование — создание новых классов на основе существующих.<br />
            Полиморфизм — возможность объектов вести себя по-разному в зависимости от контекста.<br />
            Абстракция — выделение главных характеристик объекта.<br />
            Класс — это шаблон, описывающий структуру объекта (поля, методы, свойства).<br />
            Объект — это экземпляр класса, созданный на его основе.<br />
        </div>
        <div class="code">
            // Пример класса "Person"
            class Person 
            {
                // Поля (данные)
                public string Name;
                public int Age;

                // Метод (действие)
                public void Greet() 
                {
                    Console.WriteLine($"Привет, меня зовут {Name}, мне {Age} лет!");
                }
            }

            class Program 
            {
                static void Main() 
                {
                    // Создаём объект класса Person
                    Person person1 = new Person();
        
                    // Устанавливаем значения полей
                    person1.Name = "Алексей";
                    person1.Age = 30;
        
                    // Вызываем метод
                    person1.Greet();  // Вывод: Привет, меня зовут Алексей, мне 30 лет!
                }
            }
        </div>
        <div class="text">
            Инкапсуляция — это принцип ООП, который: <br />
            Скрывает внутреннюю реализацию класса от внешнего кода.<br />
            Защищает данные от некорректного изменения.<br />
            Предоставляет контролируемый доступ через методы и свойства.
        </div>
        <div class="code">
            class Person 
            {
                private string _name;
                private int _age;

                // Свойство для доступа к имени
                public string Name 
                {
                    get { return _name; }         // Возвращает значение
                    set { _name = value; }        // Устанавливает значение
                }

                // Свойство для возраста с проверкой
                public int Age 
                {
                    get { return _age; }
                    set 
                    {
                        if (value > 0 && value < 120)  // Проверка
                            _age = value;
                        else
                            Console.WriteLine("Недопустимый возраст!");
                    }
                }

                public void Greet() 
                {
                    Console.WriteLine($"Привет, я {_name}, мне {_age} лет!");
                }
            }
        </div>
        <div class="text">
            <h4>Ассинхронность в C# (урок 4)</h4>
            В синхронном программировании операции выполняются последовательно, одна за другой. Если одна операция блокирует выполнение (например, чтение файла или запрос к серверу), вся 
            программа "зависает" до её завершения.
        </div>
        <div class="code">
            void SyncMethod()
            {
                Console.WriteLine("Начало синхронной операции...");
                Thread.Sleep(2000); // Имитация долгой операции (2 секунды)
                Console.WriteLine("Конец синхронной операции.");
            }

            SyncMethod();
            Console.WriteLine("Программа продолжает работу.");
            
            // Начало синхронной операции...
            // Конец синхронной операции.
            // Программа продолжает работу.
        </div>
        <div class="text">
            Асинхронность позволяет выполнять долгие операции без блокировки основного потока. В C# для этого используются ключевые слова async и await
        </div>
        <div class="code">
            async Task AsyncMethod()
            {
                Console.WriteLine("Начало асинхронной операции...");
                await Task.Delay(2000); // Не блокирует поток, а "ожидает" в фоне
                Console.WriteLine("Конец асинхронной операции.");
            }

            await AsyncMethod();
            Console.WriteLine("Программа продолжает работу.");

            // Вывод (такой же, но поведение другое):
            // Начало асинхронной операции...
            // Конец асинхронной операции.
            // Программа продолжает работу.
        </div>
        <div class="text">
            Во время await Task.Delay(2000) поток не блокируется, и программа может выполнять другие задачи (например, обрабатывать UI-события в приложении).<br />
            Основные понятия<br />
            async – указывает, что метод содержит асинхронные операции.<br />
            await – приостанавливает выполнение метода, пока операция не завершится, но не блокирует поток.<br />
            Task – представляет асинхронную операцию.
            <h4>Работа с файлами в C# (урок 5)</h4>
            В C# для работы с файлами используется пространство имен System.IO. Самый простой способ взаимодействия с файлами — статический класс File,
            который предоставляет методы для создания, чтения, записи, копирования и удаления файлов.<br />
            Основные методы класса File<br />
            File.Exists(path) — проверяет, существует ли файл.<br />
            File.Create(path) — создаёт файл и возвращает FileStream для записи.<br />
            File.WriteAllText(path, content) — записывает текст в файл (перезаписывает, если файл существует).<br />
            File.ReadAllText(path) — читает весь текст из файла.<br />
            File.AppendAllText(path, content) — добавляет текст в конец файла.<br />
            File.Delete(path) — удаляет файл.<br />
            File.Copy(source, destination) — копирует файл.
        </div>
        <div class="code">
            using System;
            using System.IO;

            class Program
            {
                static void Main()
                {
                    string filePath = "example.txt";
        
                    // Проверяем, существует ли файл
                    if (!File.Exists(filePath))
                    {
                        // Создаём и записываем текст в файл
                        File.WriteAllText(filePath, "Привет, мир!");
                        Console.WriteLine("Файл создан и в него записан текст.");
                    }
        
                    // Читаем содержимое файла
                    string content = File.ReadAllText(filePath);
                    Console.WriteLine($"Содержимое файла: {content}");
        
                    // Добавляем текст в файл
                    File.AppendAllText(filePath, "\nНовая строка.");
                    Console.WriteLine("Текст добавлен в файл.");
        
                    // Выводим обновлённое содержимое
                    Console.WriteLine($"Обновлённое содержимое:\n{File.ReadAllText(filePath)}");
        
                    // Удаляем файл (раскомментируйте для проверки)
                    // File.Delete(filePath);
                    // Console.WriteLine("Файл удалён.");
                }
            }
        </div>
        <div class="text">
            <h4>ДЕЛЕГАТЫ, ЛЯМБДА И СОБЫТИЯ (урок 6)</h4>
            Делегат в C# — это тип, который хранит ссылку на метод с определённой сигнатурой (типом возвращаемого значения и параметров).<br />
            Делегаты похожи на указатели на функции в C++, но безопасны и работают в управляемой среде .NET.<br />
            Они позволяют передавать методы как аргументы другим методам.<br />
            MessageDelegate — это делегат, который может указывать на любой метод, принимающий string и возвращающий void.<br />
            delegateInstance — переменная делегата, которая ссылается на метод ShowMessage.<br />
            При вызове delegateInstance("...") выполняется метод ShowMessage.
        </div>
        <div class="code">
            using System;

            // Объявляем делегат
            delegate void MessageDelegate(string message);

            class Program
            {
                static void Main()
                {
                    // Создаём экземпляр делегата и связываем его с методом ShowMessage
                    MessageDelegate delegateInstance = ShowMessage;
        
                    // Вызываем метод через делегат
                    delegateInstance("Привет, мир!");  // Выведет: Сообщение: Привет, мир!
                }

                static void ShowMessage(string text)
                {
                    Console.WriteLine($"Сообщение: {text}");
                }
            }
        </div>
        <div class="text">
            <h4>ИСКЛЮЧЕНИЯ (урок 7)</h4>
            Исключение (exception) — это ошибка, которая возникает во время выполнения программы и нарушает её нормальный поток. Например: <br />
            Деление на ноль.<br />
            Обращение к несуществующему элементу массива.<br />
            Попытка открыть несуществующий файл.<br />
            В C# исключения представлены классами, унаследованными от System.Exception.<br />
            Для обработки исключений используются три ключевых блока: <br />
            try — блок, в котором выполняется код, который может вызвать исключение.<br />
            catch — блок, который "ловит" исключение и обрабатывает его.<br />
            finally — блок, который выполняется всегда, даже если исключение произошло.<br />
            Можно ловить конкретные типы исключений (например, DivideByZeroException).<br />
            Можно использовать общий Exception для всех ошибок: <br />
        </div>
        <div class="code">
            try 
            {
                int a = 10;
                int b = 0;
                int result = a / b; // Деление на ноль → исключение!
                Console.WriteLine(result);
            }
            catch (DivideByZeroException ex) 
            {
                Console.WriteLine("Ошибка: деление на ноль!");
                Console.WriteLine(ex.Message); // Выведет стандартное сообщение об ошибке
            }
            finally 
            {
                Console.WriteLine("Этот блок выполнится в любом случае.");
            }
        </div>
        <div class="text">
            <h4>UDEMY NOTES (урок 8)</h4>
            Пример комбинирования Delegates и Generics
        </div>
        <div class="code">
            namespace UdemyLearning
            {
                public delegate int Comparison&lt;T&gt;(T x, T y);

                public class PersonSorter
                {
                    public void Sort(Person[] person, Comparison&lt;Person&gt; comparison)
                    {
                        for (int i = 0; i < person.Length - 1; i++)
                        {
                            for (int j = i + 1; j < person.Length; j++)
                            {
                                if (comparison(person[i], person[j]) > 0)
                                {
                                    Person temp = person[i];
                                    person[i] = person[j];
                                    person[j] = temp;
                                }
                            }
                        }
                    }
                }

                public class Person
                {
                    protected int _age;
                    protected string _name;

                    public string Name { get { return _name; } set { _name = value; } }

                    public int Age { get { return _age; } 
                        set
                        {
                            if (value <= 18)
                            {
                                throw new Exception();
                            } else
                            {
                                _age = value;
                            }
                        } 
                    }
                }

                internal class Program
                {
                    static void Main(string[] args)
                    {
                        Person[] people =
                        {
                            new Person {Name = "ah1", Age = 25 },
                            new Person {Name = "ch4", Age = 45 },
                            new Person {Name = "bh3", Age = 35 },
                        };

                        PersonSorter sorter = new PersonSorter();

                        sorter.Sort(people, CompareByAge);

                        foreach(Person person in people)
                        {
                            Console.WriteLine(person.Name);
                            Console.WriteLine(person.Age);
                        }

                        sorter.Sort(people, CompareByName);

                        foreach (Person person in people)
                        {
                            Console.WriteLine(person.Name);
                            Console.WriteLine(person.Age);
                        }

                        Console.ReadLine();
                    }

                    static int CompareByAge(Person x, Person y)
                    {
                        return x.Age.CompareTo(y.Age);
                    }

                    static int CompareByName(Person x, Person y)
                    {
                        return x.Name.CompareTo(y.Name);
                    }
                }
            }
        </div>
        <div class="text">
            <h3>WEB DEV</h3>
            <h4>PHP (урок 9)</h4>
            declare(strict_types=1); включает строгую проверку типов в PHP. Без него PHP пытается неявно преобразовывать типы, что может привести к неожиданным ошибкам.<br />
            Генераторы (yield) позволяют лениво (lazy evaluation) генерировать данные, экономя память.<br />
            Ключевые сценарии:<br />
            Чтение больших файлов (логи, CSV)<br />
            Потоковая обработка API-ответов<br />
            Генерация последовательностей "на лету"<br />
            Фишка: Даже если файл весит 10 ГБ, память будет использоваться только для текущей строки.
        </div>
        <div class="code">
            &lt;?php
            declare(strict_types=1);

            function readLargeFile(string $filename): iterable {
                $file = fopen($filename, 'r');
                while (!feof($file)) {
                    yield trim(fgets($file)); // Читает по одной строке, не загружая весь файл
                }
                fclose($file);
            }

            // Использование:
            foreach (readLargeFile('huge_log.txt') as $line) {
                if (str_contains($line, 'ERROR')) {
                    echo $line . PHP_EOL;
                }
            }
        </div>
        <div class="text">
            Функции высшего порядка — функции, которые принимают или возвращают другие функции.<br />
            Каррирование — преобразование функции от многих аргументов в последовательность функций одного аргумента.<br />
            Композиция функций — создание новой функции путем объединения существующих (f(g(x)))<br />
        </div>
        <div class="code">
            // Функции высшего порядка: array_map + анонимные функции
            $numbers = [1, 2, 3, 4];
            $squared = array_map(fn($x) => $x ** 2, $numbers); // [1, 4, 9, 16]

            //Каррирование
            function add(int $a): callable {
                return fn(int $b) => $a + $b;
            }

            $addFive = add(5);
            echo $addFive(10); // 15

            //Композиция функций
            function compose(callable ...$functions): callable {
                return fn($x) => array_reduce(
                    $functions,
                    fn($carry, callable $f) => $f($carry),
                    $x
                );
            }

            $double = fn($x) => $x * 2;
            $increment = fn($x) => $x + 1;

            $doubleThenIncrement = compose($double, $increment);
            echo $doubleThenIncrement(5); // 11 (5*2 + 1)
        </div>
        <div class="text">
            Паттерн "Стратегия" — это выбор алгоритма в рантайме без изменения клиентского кода.<br />
            Вместо ООП-реализации (интерфейсы + классы) используем функции как объекты первого класса.<br />
            Плюсы:<br />
            Упрощение тестирования (каждая стратегия — чистая функция).<br />
            Возможность горячей замены логики.
        </div>
        <div class="code">
            //Обычный подход (условия):
            $numbers = [-2, -1, 0, 1, 2];
            $filtered = [];
            foreach ($numbers as $number) {
                if ($number > 0) { // Жёстко зашито в код
                    $filtered[] = $number;
                }
            }

            //Функциональный "Стратегия":
            declare(strict_types=1);

            // Стратегии как чистые функции:
            $isPositive = fn(int $n): bool => $n > 0;
            $isEven = fn(int $n): bool => $n % 2 === 0;

            // Функция-компоновщик:
            function filter(array $data, callable $strategy): array {
                return array_filter($data, $strategy);
            }

            // Использование:
            $numbers = [-2, -1, 0, 1, 2];
            filter($numbers, $isPositive); // [1, 2]
            filter($numbers, $isEven);     // [-2, 0, 2]
        </div>
        <div class="text">
            <h4>LARAVEL (урок 10)</h4>
            Service Container — это ядро Laravel <br />
            Laravel Container — это мощный инструмент для управления зависимостями и выполнения внедрения зависимостей (DI).<br />
            Как это работает?<br />
            Биндинг (Binding): Регистрация классов/интерфейсов в контейнере.<br />
            Резолвинг (Resolving): Автоматическое создание экземпляров с зависимостями.<br />
        </div>
        <div class="code">
            //Простая привязка
            $this->app->bind('MyService', function ($app) {
                return new MyService($app->make('AnotherService'));
            });

            //Синглтон (одиночка)
            $this->app->singleton('CacheProvider', function ($app) {
                return new RedisCache($app->make('Redis'));
            });

            //Интерфейсы и их реализации
            $this->app->bind(
                PaymentGatewayInterface::class,
                StripePaymentGateway::class
            );

            //Автоматическое внедрение (Auto-wiring)
            class OrderController {
                public function __construct(
                    protected PaymentGatewayInterface $paymentGateway
                ) {}
            }

            //Контекстный биндинг
            $this->app->when(OrderController::class)
              ->needs(PaymentGatewayInterface::class)
              ->give(StripePaymentGateway::class);

            //Тегирование сервисов
            $this->app->tag([StripeGateway::class, PayPalGateway::class], 'payment-gateways');
            $gateways = $this->app->tagged('payment-gateways');
        </div>
        <div class="text">
            Проблема "Толстых" Моделей <br />
            В типичном Laravel-приложении логика часто пишется прямо в контроллерах или моделях, что приводит к:<br />
            Сложности тестирования.<br />
            Нарушению Single Responsibility Principle (SRP).<br />
            Трудностям при замене источника данных (например, с MySQL на API).<br />
            Решение: Репозиторий-паттерн<br />
            Репозиторий — это прослойка между бизнес-логикой и данными.<br />
        </div>
        <div class="code">
            interface UserRepositoryInterface {
                public function find(int $id): ?User;
                public function save(User $user): void;
                public function findByEmail(string $email): ?User;
            }

            class EloquentUserRepository implements UserRepositoryInterface {
                public function find(int $id): ?User {
                    return User::find($id);
                }

                public function save(User $user): void {
                    $user->save();
                }

                public function findByEmail(string $email): ?User {
                    return User::where('email', $email)->first();
                }
            }

            // Внедрение репозитория через DI
            // В сервис-провайдере:
            $this->app->bind(
                UserRepositoryInterface::class,
                EloquentUserRepository::class
            );

            // В контроллере:
            class UserController {
                public function __construct(
                    protected UserRepositoryInterface $users
                ) {}

                public function show(int $id) {
                    return $this->users->find($id);
                }
            }
        </div>
        <div class="text">
            В Laravel bind и singleton — это два метода регистрации зависимостей в Service Container, но они работают по-разному <br />
            bind() — Обычная привязка - Создает новый экземпляр при каждом обращении к контейнеру <br />
            singleton() — Одиночка - Возвращает один и тот же экземпляр при всех последующих вызовах.<br />
            bind()	Новый каждый раз	+	Запросы, уникальные контексты <br />
            singleton()	Один на все вызовы	–	Общие ресурсы (БД, конфиги)
        </div>
        <div class="code">
            // Bind
            $this->app->bind(MyService::class, function ($app) {
                return new MyService();
            });

            // Каждый раз новый объект
            $service1 = app(MyService::class); // Новый экземпляр
            $service2 = app(MyService::class); // Еще один новый экземпляр
            var_dump($service1 === $service2); // false

            // Проверка типа привязки
            dd(app()->bound(MyService::class)); // true/false
            dd(app()->isShared(MyService::class)); // true для singleton
            -----------------------------------------------
            // Singleton
            $this->app->singleton(MyService::class, function ($app) {
                return new MyService();
            });

            // Всегда один объект
            $service1 = app(MyService::class); // Создан впервые
            $service2 = app(MyService::class); // Возвращен тот же экземпляр
            var_dump($service1 === $service2); // true
            // проверка
            $this->app->instance(MyService::class, new FakeService());
        </div>
        <div class="text">
            <h3>C#</h3>
            <h4>UDEMY NOTES (урок 11)</h4>
            Код помещён в пространство имён UdemyLearning для логической группировки.<br />
            Делегат — это тип, который хранит ссылку на метод с определённой сигнатурой.<br />
            Здесь Notify может указывать на любой метод, который принимает string и возвращает void.<br />
            Класс EventPublisher (Издатель)<br />
            public event Notify OnNotify:<br />
            OnNotify — событие, основанное на делегате Notify.<br />
            Ключевое слово event добавляет защиту (подписка/отписка только через +=/-=).<br />
            OnNotify?.Invoke(message):<br />
            ?. — проверка на null (если нет подписчиков, событие не вызовется).<br />
            Invoke — вызывает все подписанные методы.<br />
            Класс EventSubscriber (Подписчик)<br />
            Метод OnEventRised соответствует сигнатуре делегата Notify (void + string).<br />
            Будет вызван при срабатывании события OnNotify<br />
            Создание объектов:<br />
            publisher — издатель события.<br />
            eventSubscriber — подписчик.<br />
            Подписка на событие:<br />
            publisher.OnNotify += eventSubscriber.OnEventRised — добавление метода OnEventRised в список вызовов события OnNotify.<br />
            Запуск события:<br />
            publisher.RaisEvent("TEST RUN") вызывает все подписанные методы (здесь — OnEventRised).<br />
            Результат:<br />
            В консоль выведется: "Event received TEST RUN".<br />
            Создаётся событие OnNotify в EventPublisher.<br />
            Подписчик (EventSubscriber) регистрирует свой метод OnEventRised через +=.<br />
            При вызове RaisEvent("TEST RUN"):<br />
            Проверяется, есть ли подписчики (?.).<br />
            Если есть, вызывается OnEventRised с переданным сообщением.<br />
            Метод OnEventRised выводит сообщение в консоль.<br />
            Инкапсуляция: Событие OnNotify объявлено как public, но подписка/отписка возможны только через += и -=.<br />
            Множественные подписчики: Можно добавить несколько методов:<br />
            publisher.OnNotify += subscriber1.Method1;<br />
            publisher.OnNotify += subscriber2.Method2;<br />
        </div>
        <div class="code">
            namespace UdemyLearning
            {

                public delegate void Notify(string message);

                public class EventPublisher
                {
                    public event Notify OnNotify;

                    public void RaisEvent(string message)
                    {
                        OnNotify?.Invoke(message);
                    }
                }

                public class EventSubscriber
                {
                    public void OnEventRised(string message)
                    {
                        Console.WriteLine("Event received " + message);
                    }
                }

                internal class Program
                {
                    static void Main(string[] args)
                    {
                        EventPublisher publisher = new EventPublisher();
                        EventSubscriber eventSubscriber = new EventSubscriber();

                        publisher.OnNotify += eventSubscriber.OnEventRised;

                        publisher.RaisEvent("TEST RUN");

                        Console.ReadKey();
                    }
                }
            }
        </div>
        <div class="text">
            <h4>ASP.NET CORE (урок 12)</h4>
            ASP.NET Core — это кроссплатформенный фреймворк для создания современных веб-приложений и API от Microsoft. Он работает на Windows, Linux и macOS.<br />
            Ключевые особенности:<br />
            Открытый исходный код (GitHub)<br />
            Высокая производительность (быстрее Node.js, Python)<br />
            Поддержка Docker и микросервисов<br />
            Гибкость (MVC, Web API, Razor Pages, Blazor)<br />
            Встроенная поддержка Dependency Injection<br />
            dotnet new web -o FirstWebApp - создаёт шаблон минимального веб-приложения <br />
            dotnet run - запускает сервер (обычно на http://localhost:5000 или https://localhost:5001)<br />
        </div>
        <div class="code">
            var builder = WebApplication.CreateBuilder(args);
            var app = builder.Build();

            app.MapGet("/", () => "Hello World!");

            app.Run();
        </div>
        <div class="text">
            WebApplication.CreateBuilder() настраивает хост приложения.<br />
            app.MapGet("/", ...) регистрирует GET-запрос для пути /.<br />
            app.Run() запускает приложение.<br />
            Middleware — это компоненты, которые обрабатывают HTTP-запросы и ответы. Они выполняются последовательно, образуя конвейер (pipeline).<br />
            Примеры встроенного Middleware:<br />
            Статические файлы (app.UseStaticFiles())<br />
            Маршрутизация (app.UseRouting())<br />
            Аутентификация (app.UseAuthentication())<br />
            Как работает конвейер Middleware?<br />
            Запрос проходит через Middleware в порядке их регистрации, а ответ — в обратном порядке.<br />
            Запрос → Middleware 1 → Middleware 2 → ... → Middleware N → Ваш endpoint <br />
            Ответ ← Middleware 1 ← Middleware 2 ← ... ← Middleware N ← Ваш endpoint <br />
            При запросе сначала выполнится Console.WriteLine("До обработки запроса").<br />
            await next() передаёт управление следующему Middleware (в данном случае — маршруту /).<br />
            После формирования ответа выполнится Console.WriteLine("После обработки запроса").<br />
            app.UseHttpLogging(); // Требует подключения пакета Microsoft.AspNetCore.HttpLogging<br />
            app.UseExceptionHandler("/error"); // Перенаправление на страницу ошибки<br />
            app.UseStaticFiles(); // Раздаёт файлы из wwwroot
        </div>
        <div class="code">
            var builder = WebApplication.CreateBuilder(args);
            var app = builder.Build();

            // Добавляем Middleware
            app.Use(async (context, next) =>
            {
                Console.WriteLine("До обработки запроса");
                await next(); // Передаём запрос следующему Middleware
                Console.WriteLine("После обработки запроса");
            });

            app.MapGet("/", () => "Главная страница");

            app.Run();
        </div>
        <div class="text">
            <h4>ASP.NET CORE MVC (урок 13)</h4>
            ASP.NET Core MVC — это фреймворк для создания веб-приложений на основе паттерна Model-View-Controller (MVC), разработанный Microsoft.<br />
            Кроссплатформенный (работает на Windows, Linux, macOS)<br />
            Высокопроизводительный<br />
            Модульный (использует middleware)<br />
            Поддерживает Dependency Injection "из коробки"<br />
            Работает с .NET Core/.NET 5+<br />
            Основные компоненты MVC:<br />
            Model - представляет данные и бизнес-логику<br />
            View - отвечает за отображение данных (HTML-страницы)<br />
            Controller - обрабатывает запросы пользователя, работает с Model и возвращает View<br />
            dotnet new mvc -n MyFirstMvcApp<br />
            dotnet run<br />
            Структура проекта:<br />
            /Controllers - папка с контроллерами<br />
            /Views - папка с представлениями<br />
            /wwwroot - статические файлы (CSS, JS, изображения)<br />
            Program.cs - точка входа и конфигурация приложения<br />
            appsettings.json - файл конфигурации<br />
        </div>
        <div class="code">
            //HomeController.cs
            public class HomeController : Controller
            {
                public IActionResult Index()
                {
                    return View(); // Возвращает представление Views/Home/Index.cshtml
                }

                public IActionResult Welcome()
                {
                    ViewData["Message"] = "Добро пожаловать в ASP.NET Core MVC!";
                    return View();
                }
            }
            //Views/Home/Welcome.cshtml
            @{
                ViewData["Title"] = "Страница приветствия";
            }
            <h1>@ViewData["Message"]</h1>
        </div>
        <div class="text">
            Маршрутизация — это процесс определения того, какой контроллер и какое действие (action) должны обработать HTTP-запрос на основе URL.
            В ASP.NET Core MVC используется система маршрутов, которая анализирует URL и выбирает подходящий обработчик.<br />
            В ASP.NET Core MVC есть два основных подхода: <br />
            Обычная (Conventional) маршрутизация – на основе шаблонов в Program.cs.<br />
            Атрибутная маршрутизация – маршруты задаются атрибутами прямо над контроллерами и методами.<br />
            По умолчанию в Program.cs уже есть стандартный маршрут:
        </div>
        <div class="code">
            // {controller=Home} – если контроллер не указан, используется HomeController.
            // {action=Index} – если действие не указано, вызывается Index().
            // {id?} – параметр id является необязательным
            
            app.MapControllerRoute(
                name: "default",
                pattern: "{controller=Home}/{action=Index}/{id?}");
        </div>
        <div class="text">
            Более гибкий подход — задание маршрутов прямо в коде контроллера <br />
            Более точный контроль над URL.<br />
            Возможность сложных шаблонов (ограничения типов, несколько маршрутов для одного метода).<br />
        </div>
        <div class="code">
            [Route("products")]
            public class ProductsController : Controller
            {
                [HttpGet("list")]  // Обрабатывает GET /products/list
                public IActionResult Index() { ... }

                [HttpGet("{id:int}")]  // Обрабатывает GET /products/5 (только числа)
                public IActionResult Details(int id) { ... }
            }
        </div>
        <div class="text">
            Можно указывать типы параметров прямо в маршруте
        </div>
        <div class="code">
            [Route("users/{id:int}")]  // Только целые числа
            public IActionResult GetUser(int id) { ... }

            [Route("posts/{slug:alpha}")]  // Только буквы
            public IActionResult GetPost(string slug) { ... }
        </div>
        <div class="text">
            <h4>МИНИМАЛЬНЫЕ API (урок 14)</h4>
            Minimal API — это упрощённый подход к созданию HTTP API в .NET, который позволяет быстро создавать микро-сервисы и веб-API
            с минимальным количеством кода и настройки. В отличие от традиционного ASP.NET Core (с контроллерами), Minimal API требует меньше шаблонного кода.<br />
            Ключевые особенности:<br />
            Минимальная конфигурация<br />
            Прямое определение маршрутов и методов<br />
            Идеально для небольших API и микросервисов<br />
            dotnet new web -o MinimalApiDemo
        </div>
        <div class="code">
            // Program.cs
            // WebApplication.CreateBuilder(args) — создаёт "строитель" приложения
            // app.MapGet("/", ...) — определяет GET-эндпоинт для пути /.
            // app.Run() — запускает приложение.

            var builder = WebApplication.CreateBuilder(args);
            var app = builder.Build();

            app.MapGet("/", () => "Hello World!");
            app.MapGet("/welcome", () => "Welcome to Minimal API!");

            app.Run();
        </div>
        <div class="text">
            <h4>Аутентификация и Авторизация (урок 15)</h4>
            Основные понятия <br />
            Аутентификация (Authentication) — процесс проверки, что пользователь действительно тот, за кого себя выдаёт (например, через логин и пароль).<br />
            Авторизация (Authorization) — проверка прав пользователя на доступ к определённым ресурсам (например, доступ к админ-панели).<br />
            Разница между аутентификацией и авторизацией <br />
            Аутентификация → "Кто ты?" (проверка личности).<br />
            Авторизация → "Что тебе разрешено?" (проверка прав).<br />
            Основные методы аутентификации <br />
            Сессии и куки (традиционный способ, stateful).<br />
            JWT (JSON Web Tokens) (современный, stateless подход).<br />
            OAuth / OpenID Connect (используется для делегированного доступа, например "Войти через Google").<br />
            Identity Framework (например, ASP.NET Core Identity — готовая система управления пользователями).
            <h4>Dependency Injection (DI) и сервисы (урок 16)</h4>
            Представь, у тебя есть класс Car, который зависит от класса Engine <br />
            Жёсткая связь (tight coupling) – Car зависит от конкретной реализации Engine.<br />
            Сложно тестировать – нельзя подменить Engine на заглушку (mock).<br />
            Трудно менять реализацию – если завтра понадобится ElectricEngine, придётся переписывать Car.
        </div>
        <div class="code">
            public class Engine 
            {
                public void Start() => Console.WriteLine("Engine started!");
            }

            public class Car 
            {
                private Engine _engine;

                public Car() 
                {
                    _engine = new Engine();  // Прямое создание зависимости
                }

                public void StartCar() 
                {
                    _engine.Start();
                }
            }
        </div>
        <div class="text">
            DI — это паттерн проектирования, при котором зависимости не создаются внутри класса, а "внедряются" извне.<br />
            Гибкость – можно подменить реализацию IEngine (например, на ElectricEngine).<br />
            Тестируемость – в тестах можно передавать MockEngine.<br />
            Уменьшение связанности кода.
        </div>
        <div class="code">
            public interface IEngine 
            {
                void Start();
            }

            public class Engine : IEngine 
            {
                public void Start() => Console.WriteLine("Engine started!");
            }

            public class Car 
            {
                private readonly IEngine _engine;

                // Зависимость внедряется через конструктор (Constructor Injection)
                public Car(IEngine engine) 
                {
                    _engine = engine;
                }

                public void StartCar() 
                {
                    _engine.Start();
                }
            }
        </div>
        <div class="text">
            Основные способы внедрения зависимостей <br />
            Constructor Injection (через конструктор) – самый частый способ.<br />
            Property Injection (через свойство) – реже, используется, например, в UI-фреймворках.<br />
            Method Injection (через метод) – если зависимость нужна только в одном методе.
            <h4>Middleware и кастомизации запросов (урок 17)</h4>
            Middleware — это промежуточное программное обеспечение, которое обрабатывает HTTP-запросы и ответы в конвейере.<br />
            Это функции или компоненты, которые выполняются между получением запроса и отправкой ответа.<br />
            Middleware может:<br />
            Логировать запросы<br />
            Авторизовать пользователей<br />
            Обрабатывать ошибки<br />
            Модифицировать запрос/ответ<br />
            Каждый middleware может: <br />
            Обработать запрос и передать его дальше (next()).<br />
            Прервать конвейер и сразу отправить ответ <br />
            Порядок middleware важен – они выполняются последовательно.<br />
            Middleware может завершить запрос (если не вызвать next()).<br />
            Middleware может изменять req и res (например, добавлять заголовки
        </div>
        <div class="code">
            app.use((req, res, next) => {
                console.log("Middleware 1: Запрос получен");
                next(); // Передать управление следующему middleware
            });

            app.use((req, res, next) => {
                console.log("Middleware 2: Проверка авторизации");
                if (user.isAuthenticated) {
                    next();
                } else {
                    res.status(403).send("Доступ запрещен!");
                }
            });

            app.get("/", (req, res) => {
                res.send("Главная страница");
            });
        </div>
        <div class="text">
            <h4>SignalR (урок 18)</h4>
            1. Что такое SignalR? <br />
            SignalR — это библиотека ASP.NET, которая упрощает создание веб-приложений реального времени (real-time). Она позволяет серверу мгновенно отправлять данные клиентам без постоянных HTTP-запросов.<br />
            2. Где используется?<br />
            Чат-приложения (WhatsApp, Telegram Web)<br />
            Уведомления (Facebook, Twitter)<br />
            Онлайн-игры (мультиплеерные игры)<br />
            Биржевые графики (обновление котировок)<br />
            Совместная работа (Google Docs, Figma)<br />
            3. Как работает SignalR?<br />
            Использует WebSockets (если поддерживаются браузером и сервером).<br />
            Если WebSockets недоступны, автоматически переключается на Long Polling, Server-Sent Events (SSE).<br />
            Поддерживает RPC (Remote Procedure Call) — сервер может вызывать методы клиента, а клиент — сервера.<br />
            4. Основные компоненты<br />
            Хаб (Hub) — центральный класс, через который клиенты и сервер обмениваются сообщениями.<br />
            Клиенты (JavaScript, .NET, Java и др.) — подключаются к хабу и получают/отправляют сообщения.<br />
            Транспорты (WebSocket, Server-Sent Events, Long Polling) — механизмы передачи данных.
        </div>
        <div class="code">
            // Серверный хаб
            public class ChatHub : Hub
            {
                public async Task SendMessage(string user, string message)
                {
                    await Clients.All.SendAsync("ReceiveMessage", user, message);
                }
            }
            -----------------------------------------------------------------------------
            // Клиент (JavaScript)
            const connection = new signalR.HubConnectionBuilder()
                .withUrl("/chatHub")
                .build();

            connection.on("ReceiveMessage", (user, message) => {
                console.log(`${user}: ${message}`);
            });

            connection.start();
        </div>
        <div class="text">
            <h4>ТЕСТИРОВАНИЕ (урок 19)</h4>
            1. Зачем нужно тестирование? <br />
            Раннее обнаружение багов<br />
            Уверенность при рефакторинге<br />
            Документирование поведения кода<br />
            Сокращение времени на ручное тестирование<br />
            2. Типы тестов:<br />
            Unit-тесты - тестирование отдельных компонентов изолированно<br />
            Integration-тесты - проверка взаимодействия компонентов<br />
            E2E-тесты - тестирование системы в целом (как пользователь)<br />
            Добавьте тестовый проект xUnit: dotnet new xunit -n MyProject.Tests <br />
            Добавьте ссылку на основной проект в тестовый: dotnet add MyProject.Tests reference MyProject <br />
            Запуск тестов: dotnet test
        </div>
        <div class="code">
            // В проекте MyProject.Tests создайте файл SampleTests.cs:
            using Xunit;

            namespace MyProject.Tests
            {
                public class SampleTests
                {
                    [Fact]
                    public void TestAddition()
                    {
                        // Arrange
                        int a = 5;
                        int b = 3;
            
                        // Act
                        int result = a + b;
            
                        // Assert
                        Assert.Equal(8, result);
                    }
                }
            }
        </div>
        <div class="text">
            <h4>RAZOR PAGES (урок 20)</h4>
            Razor Pages — это технология Microsoft для создания веб-приложений на C#. Она основана на паттерне MVVM (Model-View-ViewModel)
            и упрощает разработку странично-ориентированных приложений по сравнению с традиционным MVC.<br />
            Структура проекта <br />
            Pages — содержит Razor-страницы (.cshtml и .cshtml.cs).<br />
            wwwroot — для статических файлов (CSS, JS, изображения).<br />
            appsettings.json — настройки приложения.<br />
            Открой папку Pages → удали дефолтные страницы (кроме _Layout.cshtml и _ViewImports.cshtml).<br />
            Создай новую страницу:<br />
            ПКМ на Pages → Add → Razor Page → Razor Page (Empty) → назови Index.cshtml.<br />
            В Index.cshtml напиши: <br />
            Разбор кода<br />
            @page — директива, которая делает файл Razor Page (обязательна для каждой страницы).<br />
            @DateTime.Now — вставка C#-кода в HTML (Razor-синтаксис).
        </div>
        <div class="code">
            @page
            &lt;h&gt;>Привет, мир!&lt;/h1&gt;
            &lt;p&gt;Текущее время: @DateTime.Now&lt;/p&gt;
        </div>
        <div class="text">
            <h4>BLAZOR (урок 21)</h4>
            Blazor — это веб-фреймворк от Microsoft, который позволяет создавать интерактивные веб-приложения используя C# вместо JavaScript. Есть две основные модели размещения: <br />
            Blazor Server: Логика выполняется на сервере, обновления DOM передаются через SignalR<br />
            Blazor WebAssembly: Приложение выполняется полностью в браузере на WebAssembly<br />
            dotnet new blazorserver -o FirstBlazorApp --no-https <br />
            dotnet run <br />
            Основные файлы и папки: <br />
            Program.cs — точка входа<br />
            Pages/ — содержит Razor-компоненты (страницы)<br />
            Index.razor — главная страница<br />
            Counter.razor — пример счётчика<br />
            FetchData.razor — пример загрузки данных<br />
            Shared/ — общие компоненты<br />
            MainLayout.razor — основной макет<br />
            wwwroot/ — статические файлы (css, js, изображения)<br />
        </div>
        <div class="code">
            @page "/counter"

            &lt;h1&gt;Счётчик&lt;/h1&gt;

            &lt;p&gt;Текущее значение: @currentCount&lt;/p&gt;

            &lt;button class="btn btn-primary" @onclick="IncrementCount"&gt;Увеличить&lt;/button&gt;
            &lt;button class="btn btn-danger" @onclick="DecrementCount"&gt;Уменьшить&lt;/button&gt;
            &lt;button class="btn btn-warning" @onclick="ResetCount"&gt;Сбросить&lt;/button&gt;

            @code {
                private int currentCount = 0;

                private void IncrementCount()
                {
                    currentCount++;
                }

                private void DecrementCount()
                {
                    if (currentCount &gt; 0)
                        currentCount--;
                }

                private void ResetCount()
                {
                    currentCount = 0;
                }
            }
        </div>
    </main>
</body>
</html>

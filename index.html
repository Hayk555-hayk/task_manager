<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЗАДАЧИ</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <main>
        <div class="text">
            <h3>C#</h3>
            <h4>ОСНОВЫ ЯЗЫКА C# (урок 1)</h4>
            C# — это современный, объектно-ориентированный язык программирования, разработанный Microsoft. Он используется для: <br />
            Создания desktop-приложений (Windows Forms, WPF)<br />
            Веб-разработки (ASP.NET, Blazor)<br />
            Мобильных приложений (Xamarin, MAUI)<br />
            Игр (Unity)<br />
            Серверных приложений (Microservices, API)<br />
        </div>
        <div class="code">
            // Program.cs точка входа программы
            // Это комментарий — он не влияет на код
            using System; // Подключение пространства имён System

            class Program // Объявление класса Program
            {
                static void Main(string[] args) // Главный метод программы
                {
                    Console.WriteLine("Hello, World!"); // Вывод текста в консоль
                }
            }
        </div>
        <div class="text">
            Переменная — это именованная область памяти, которая хранит данные. У каждой переменной есть: <br />
            Имя (например, age, name)<br />
            Тип данных (например, число, текст)<br />
            Значение (например, 25, "Анна")<br />
            Основные типы данных<br />
            int	10, -5	Целое число<br />
            double	3.14, -0.5	Число с плавающей точкой<br />
            bool	true, false	Логический тип (истина/ложь)<br />
            char	'A', 'ж'	Один символ<br />
            string	"Привет"	Строка (текст)<br />
            const double PI = 3.14159; - Используйте const, если значение не должно меняться
        </div>
        <div class="code">
            int age = 25;                  // Целое число
            double height = 1.75;          // Число с плавающей точкой
            string name = "Иван";          // Строка
            bool isStudent = true;         // Логическое значение
            char grade = 'A';              // Один символ
        </div>
        <div class="text">
            В C# для чтения ввода с клавиатуры используется метод Console.ReadLine() <br />
            Convert.ToInt32()	int age = Convert.ToInt32("25");	Преобразует строку в целое число. Если строка не число — ошибка.<br />
            int.Parse()	int num = int.Parse("10");	Аналогично Convert, но менее гибкий.<br />
            int.TryParse()	int.TryParse("abc", out _)	Безопасный метод. Возвращает true/false в зависимости от успеха.<br />
        </div>
        <div class="code">
            Console.Write("Введите ваше имя: ");  // Вывод подсказки (без перевода строки)
            string userName = Console.ReadLine();  // Чтение ввода

            Console.WriteLine($"Привет, {userName}!");

            -----------------------------------------------------

            Console.Write("Сколько вам лет? ");
            string input = Console.ReadLine();  // Пользователь вводит "30" (но это всё ещё строка!)
            int age = Convert.ToInt32(input);   // Преобразуем строку в число

            Console.WriteLine($"Через 10 лет вам будет {age + 10}");  // Можно делать вычисления!

            -----------------------------------------------------

            Console.Write("Введите число: ");
            string input = Console.ReadLine();
            int number;

            if (int.TryParse(input, out number))  // Если преобразование удалось
            {
                Console.WriteLine($"Вы ввели: {number}");
            }
            else  // Если ввели не число
            {
                Console.WriteLine("Ошибка: это не число!");
            }
        </div>
        <div class="text">
            Конструкции if/else if/else, switch/case/break/default
        </div>
        <div class="code">
            if (number > 0) 
            {
                Console.WriteLine("Положительное!");
            } 
            else if (number < 0) 
            {
                Console.WriteLine("Отрицательное!");
            } 
            else 
            {
                Console.WriteLine("Это ноль!");
            }

            ------------------------------------

            Console.Write("Введите цифру от 1 до 3: ");
            int digit = Convert.ToInt32(Console.ReadLine());

            switch (digit) 
            {
                case 1:
                    Console.WriteLine("Вы выбрали 1");
                    break;
                case 2:
                    Console.WriteLine("Вы выбрали 2");
                    break;
                case 3:
                    Console.WriteLine("Вы выбрали 3");
                    break;
                default:
                    Console.WriteLine("Неизвестная цифра");
                    break;
            }
        </div>
        <div class="text">
            <h4>ПЛАТФОРМА .NET (урок 2)</h4>
            .NET — это кроссплатформенная платформа для разработки приложений, созданная Microsoft. Она включает: <br />
            Языки программирования (C#, F#, VB.NET)<br />
            Библиотеки классов (готовые компоненты для работы с файлами, сетью, базами данных и т. д.)<br />
            Среды выполнения (CLR — Common Language Runtime)<br />
            Поддерживает:<br />
            Windows, Linux, macOS<br />
            Веб, мобильные, десктоп, игры, IoT, AI<br />
            Основные компоненты .NET<br />
            CLR (Common Language Runtime) – исполняет код, управляет памятью, безопасностью.<br />
            FCL (Framework Class Library) – стандартные библиотеки для работы с коллекциями, файлами, сетью и т. д.<br />
            Roslyn – компилятор C#.<br />
            ASP.NET Core – фреймворк для веб-приложений.<br />
            Entity Framework – ORM для работы с базами данных.<br />
            .NET vs .NET Core vs .NET Framework<br />
            .NET Framework – старая версия (только Windows).<br />
            .NET Core – кроссплатформенный преемник (2016).<br />
            .NET 5+ – единая платформа (с 2020, объединила Core и Framework).<br />
            Как работает .NET?<br />
            Вы пишете код на C#.<br />
            Компилятор превращает его в CIL (Common Intermediate Language).<br />
            CLR компилирует CIL в машинный код (JIT-компиляция).<br />
            Приложение выполняется.<br />
            В папке MyApp появились файлы:<br />
            Program.cs — основной файл с кодом.<br />
            MyApp.csproj — конфигурация проекта (зависимости, версия .NET).<br />
            dotnet new	Создаёт новый проект<br />
            dotnet run	Запускает приложение<br />
            dotnet build	Компилирует проект<br />
            dotnet restore	Восстанавливает зависимости<br />
            <h4>ООП в C# (урок 3)</h4>
            ООП — это методология программирования, основанная на использовании объектов и классов.<br />
            Основные принципы ООП:<br />
            Инкапсуляция — скрытие внутренней реализации.<br />
            Наследование — создание новых классов на основе существующих.<br />
            Полиморфизм — возможность объектов вести себя по-разному в зависимости от контекста.<br />
            Абстракция — выделение главных характеристик объекта.<br />
            Класс — это шаблон, описывающий структуру объекта (поля, методы, свойства).<br />
            Объект — это экземпляр класса, созданный на его основе.<br />
        </div>
        <div class="code">
            // Пример класса "Person"
            class Person 
            {
                // Поля (данные)
                public string Name;
                public int Age;

                // Метод (действие)
                public void Greet() 
                {
                    Console.WriteLine($"Привет, меня зовут {Name}, мне {Age} лет!");
                }
            }

            class Program 
            {
                static void Main() 
                {
                    // Создаём объект класса Person
                    Person person1 = new Person();
        
                    // Устанавливаем значения полей
                    person1.Name = "Алексей";
                    person1.Age = 30;
        
                    // Вызываем метод
                    person1.Greet();  // Вывод: Привет, меня зовут Алексей, мне 30 лет!
                }
            }
        </div>
        <div class="text">
            Инкапсуляция — это принцип ООП, который: <br />
            Скрывает внутреннюю реализацию класса от внешнего кода.<br />
            Защищает данные от некорректного изменения.<br />
            Предоставляет контролируемый доступ через методы и свойства.
        </div>
        <div class="code">
            class Person 
            {
                private string _name;
                private int _age;

                // Свойство для доступа к имени
                public string Name 
                {
                    get { return _name; }         // Возвращает значение
                    set { _name = value; }        // Устанавливает значение
                }

                // Свойство для возраста с проверкой
                public int Age 
                {
                    get { return _age; }
                    set 
                    {
                        if (value > 0 && value < 120)  // Проверка
                            _age = value;
                        else
                            Console.WriteLine("Недопустимый возраст!");
                    }
                }

                public void Greet() 
                {
                    Console.WriteLine($"Привет, я {_name}, мне {_age} лет!");
                }
            }
        </div>
        <div class="text">
            <h4>Ассинхронность в C# (урок 4)</h4>
            В синхронном программировании операции выполняются последовательно, одна за другой. Если одна операция блокирует выполнение (например, чтение файла или запрос к серверу), вся 
            программа "зависает" до её завершения.
        </div>
        <div class="code">
            void SyncMethod()
            {
                Console.WriteLine("Начало синхронной операции...");
                Thread.Sleep(2000); // Имитация долгой операции (2 секунды)
                Console.WriteLine("Конец синхронной операции.");
            }

            SyncMethod();
            Console.WriteLine("Программа продолжает работу.");
            
            // Начало синхронной операции...
            // Конец синхронной операции.
            // Программа продолжает работу.
        </div>
        <div class="text">
            Асинхронность позволяет выполнять долгие операции без блокировки основного потока. В C# для этого используются ключевые слова async и await
        </div>
        <div class="code">
            async Task AsyncMethod()
            {
                Console.WriteLine("Начало асинхронной операции...");
                await Task.Delay(2000); // Не блокирует поток, а "ожидает" в фоне
                Console.WriteLine("Конец асинхронной операции.");
            }

            await AsyncMethod();
            Console.WriteLine("Программа продолжает работу.");

            // Вывод (такой же, но поведение другое):
            // Начало асинхронной операции...
            // Конец асинхронной операции.
            // Программа продолжает работу.
        </div>
        <div class="text">
            Во время await Task.Delay(2000) поток не блокируется, и программа может выполнять другие задачи (например, обрабатывать UI-события в приложении).<br />
            Основные понятия<br />
            async – указывает, что метод содержит асинхронные операции.<br />
            await – приостанавливает выполнение метода, пока операция не завершится, но не блокирует поток.<br />
            Task – представляет асинхронную операцию.
            <h4>Работа с файлами в C# (урок 5)</h4>
            В C# для работы с файлами используется пространство имен System.IO. Самый простой способ взаимодействия с файлами — статический класс File,
            который предоставляет методы для создания, чтения, записи, копирования и удаления файлов.<br />
            Основные методы класса File<br />
            File.Exists(path) — проверяет, существует ли файл.<br />
            File.Create(path) — создаёт файл и возвращает FileStream для записи.<br />
            File.WriteAllText(path, content) — записывает текст в файл (перезаписывает, если файл существует).<br />
            File.ReadAllText(path) — читает весь текст из файла.<br />
            File.AppendAllText(path, content) — добавляет текст в конец файла.<br />
            File.Delete(path) — удаляет файл.<br />
            File.Copy(source, destination) — копирует файл.
        </div>
        <div class="code">
            using System;
            using System.IO;

            class Program
            {
                static void Main()
                {
                    string filePath = "example.txt";
        
                    // Проверяем, существует ли файл
                    if (!File.Exists(filePath))
                    {
                        // Создаём и записываем текст в файл
                        File.WriteAllText(filePath, "Привет, мир!");
                        Console.WriteLine("Файл создан и в него записан текст.");
                    }
        
                    // Читаем содержимое файла
                    string content = File.ReadAllText(filePath);
                    Console.WriteLine($"Содержимое файла: {content}");
        
                    // Добавляем текст в файл
                    File.AppendAllText(filePath, "\nНовая строка.");
                    Console.WriteLine("Текст добавлен в файл.");
        
                    // Выводим обновлённое содержимое
                    Console.WriteLine($"Обновлённое содержимое:\n{File.ReadAllText(filePath)}");
        
                    // Удаляем файл (раскомментируйте для проверки)
                    // File.Delete(filePath);
                    // Console.WriteLine("Файл удалён.");
                }
            }
        </div>
        <div class="text">
            <h4>ДЕЛЕГАТЫ, ЛЯМБДА И СОБЫТИЯ (урок 6)</h4>
            Делегат в C# — это тип, который хранит ссылку на метод с определённой сигнатурой (типом возвращаемого значения и параметров).<br />
            Делегаты похожи на указатели на функции в C++, но безопасны и работают в управляемой среде .NET.<br />
            Они позволяют передавать методы как аргументы другим методам.<br />
            MessageDelegate — это делегат, который может указывать на любой метод, принимающий string и возвращающий void.<br />
            delegateInstance — переменная делегата, которая ссылается на метод ShowMessage.<br />
            При вызове delegateInstance("...") выполняется метод ShowMessage.
        </div>
        <div class="code">
            using System;

            // Объявляем делегат
            delegate void MessageDelegate(string message);

            class Program
            {
                static void Main()
                {
                    // Создаём экземпляр делегата и связываем его с методом ShowMessage
                    MessageDelegate delegateInstance = ShowMessage;
        
                    // Вызываем метод через делегат
                    delegateInstance("Привет, мир!");  // Выведет: Сообщение: Привет, мир!
                }

                static void ShowMessage(string text)
                {
                    Console.WriteLine($"Сообщение: {text}");
                }
            }
        </div>
        <div class="text">
            <h4>ИСКЛЮЧЕНИЯ (урок 7)</h4>
            Исключение (exception) — это ошибка, которая возникает во время выполнения программы и нарушает её нормальный поток. Например: <br />
            Деление на ноль.<br />
            Обращение к несуществующему элементу массива.<br />
            Попытка открыть несуществующий файл.<br />
            В C# исключения представлены классами, унаследованными от System.Exception.<br />
            Для обработки исключений используются три ключевых блока: <br />
            try — блок, в котором выполняется код, который может вызвать исключение.<br />
            catch — блок, который "ловит" исключение и обрабатывает его.<br />
            finally — блок, который выполняется всегда, даже если исключение произошло.<br />
            Можно ловить конкретные типы исключений (например, DivideByZeroException).<br />
            Можно использовать общий Exception для всех ошибок: <br />
        </div>
        <div class="code">
            try 
            {
                int a = 10;
                int b = 0;
                int result = a / b; // Деление на ноль → исключение!
                Console.WriteLine(result);
            }
            catch (DivideByZeroException ex) 
            {
                Console.WriteLine("Ошибка: деление на ноль!");
                Console.WriteLine(ex.Message); // Выведет стандартное сообщение об ошибке
            }
            finally 
            {
                Console.WriteLine("Этот блок выполнится в любом случае.");
            }
        </div>
        <div class="text">
            <h4>UDEMY NOTES (урок 8)</h4>
            Пример комбинирования Delegates и Generics
        </div>
        <div class="code">
            namespace UdemyLearning
            {
                public delegate int Comparison<T>(T x, T y);

                public class PersonSorter
                {
                    public void Sort(Person[] person, Comparison<Person> comparison)
                    {
                        for (int i = 0; i < person.Length - 1; i++)
                        {
                            for (int j = i + 1; j < person.Length; j++)
                            {
                                if (comparison(person[i], person[j]) > 0)
                                {
                                    Person temp = person[i];
                                    person[i] = person[j];
                                    person[j] = temp;
                                }
                            }
                        }
                    }
                }

                public class Person
                {
                    protected int _age;
                    protected string _name;

                    public string Name { get { return _name; } set { _name = value; } }

                    public int Age { get { return _age; } 
                        set
                        {
                            if (value <= 18)
                            {
                                throw new Exception();
                            } else
                            {
                                _age = value;
                            }
                        } 
                    }
                }

                internal class Program
                {
                    static void Main(string[] args)
                    {
                        Person[] people =
                        {
                            new Person {Name = "ah1", Age = 25 },
                            new Person {Name = "ch4", Age = 45 },
                            new Person {Name = "bh3", Age = 35 },
                        };

                        PersonSorter sorter = new PersonSorter();

                        sorter.Sort(people, CompareByAge);

                        foreach(Person person in people)
                        {
                            Console.WriteLine(person.Name);
                            Console.WriteLine(person.Age);
                        }

                        sorter.Sort(people, CompareByName);

                        foreach (Person person in people)
                        {
                            Console.WriteLine(person.Name);
                            Console.WriteLine(person.Age);
                        }

                        Console.ReadLine();
                    }

                    static int CompareByAge(Person x, Person y)
                    {
                        return x.Age.CompareTo(y.Age);
                    }

                    static int CompareByName(Person x, Person y)
                    {
                        return x.Name.CompareTo(y.Name);
                    }
                }
            }
        </div>
        <div class="text">
            <h3>WEB DEV</h3>
            <h4>PHP (урок 9)</h4>
            declare(strict_types=1); включает строгую проверку типов в PHP. Без него PHP пытается неявно преобразовывать типы, что может привести к неожиданным ошибкам.<br />
            Генераторы (yield) позволяют лениво (lazy evaluation) генерировать данные, экономя память.<br />
            Ключевые сценарии:<br />
            Чтение больших файлов (логи, CSV)<br />
            Потоковая обработка API-ответов<br />
            Генерация последовательностей "на лету"<br />
            Фишка: Даже если файл весит 10 ГБ, память будет использоваться только для текущей строки.
        </div>
        <div class="code">
            &lt;?php
            declare(strict_types=1);

            function readLargeFile(string $filename): iterable {
                $file = fopen($filename, 'r');
                while (!feof($file)) {
                    yield trim(fgets($file)); // Читает по одной строке, не загружая весь файл
                }
                fclose($file);
            }

            // Использование:
            foreach (readLargeFile('huge_log.txt') as $line) {
                if (str_contains($line, 'ERROR')) {
                    echo $line . PHP_EOL;
                }
            }
        </div>
        <div class="text">
            Функции высшего порядка — функции, которые принимают или возвращают другие функции.<br />
            Каррирование — преобразование функции от многих аргументов в последовательность функций одного аргумента.<br />
            Композиция функций — создание новой функции путем объединения существующих (f(g(x)))<br />
        </div>
        <div class="code">
            // Функции высшего порядка: array_map + анонимные функции
            $numbers = [1, 2, 3, 4];
            $squared = array_map(fn($x) => $x ** 2, $numbers); // [1, 4, 9, 16]

            //Каррирование
            function add(int $a): callable {
                return fn(int $b) => $a + $b;
            }

            $addFive = add(5);
            echo $addFive(10); // 15

            //Композиция функций
            function compose(callable ...$functions): callable {
                return fn($x) => array_reduce(
                    $functions,
                    fn($carry, callable $f) => $f($carry),
                    $x
                );
            }

            $double = fn($x) => $x * 2;
            $increment = fn($x) => $x + 1;

            $doubleThenIncrement = compose($double, $increment);
            echo $doubleThenIncrement(5); // 11 (5*2 + 1)
        </div>
        <div class="text">
            Паттерн "Стратегия" — это выбор алгоритма в рантайме без изменения клиентского кода.<br />
            Вместо ООП-реализации (интерфейсы + классы) используем функции как объекты первого класса.<br />
            Плюсы:<br />
            Упрощение тестирования (каждая стратегия — чистая функция).<br />
            Возможность горячей замены логики.
        </div>
        <div class="code">
            //Обычный подход (условия):
            $numbers = [-2, -1, 0, 1, 2];
            $filtered = [];
            foreach ($numbers as $number) {
                if ($number > 0) { // Жёстко зашито в код
                    $filtered[] = $number;
                }
            }

            //Функциональный "Стратегия":
            declare(strict_types=1);

            // Стратегии как чистые функции:
            $isPositive = fn(int $n): bool => $n > 0;
            $isEven = fn(int $n): bool => $n % 2 === 0;

            // Функция-компоновщик:
            function filter(array $data, callable $strategy): array {
                return array_filter($data, $strategy);
            }

            // Использование:
            $numbers = [-2, -1, 0, 1, 2];
            filter($numbers, $isPositive); // [1, 2]
            filter($numbers, $isEven);     // [-2, 0, 2]
        </div>
        <div class="text">
            <h4>LARAVEL (урок 10)</h4>
            Service Container — это ядро Laravel <br />
            Laravel Container — это мощный инструмент для управления зависимостями и выполнения внедрения зависимостей (DI).<br />
            Как это работает?<br />
            Биндинг (Binding): Регистрация классов/интерфейсов в контейнере.<br />
            Резолвинг (Resolving): Автоматическое создание экземпляров с зависимостями.<br />
        </div>
        <div class="code">
            //Простая привязка
            $this->app->bind('MyService', function ($app) {
                return new MyService($app->make('AnotherService'));
            });

            //Синглтон (одиночка)
            $this->app->singleton('CacheProvider', function ($app) {
                return new RedisCache($app->make('Redis'));
            });

            //Интерфейсы и их реализации
            $this->app->bind(
                PaymentGatewayInterface::class,
                StripePaymentGateway::class
            );

            //Автоматическое внедрение (Auto-wiring)
            class OrderController {
                public function __construct(
                    protected PaymentGatewayInterface $paymentGateway
                ) {}
            }

            //Контекстный биндинг
            $this->app->when(OrderController::class)
              ->needs(PaymentGatewayInterface::class)
              ->give(StripePaymentGateway::class);

            //Тегирование сервисов
            $this->app->tag([StripeGateway::class, PayPalGateway::class], 'payment-gateways');
            $gateways = $this->app->tagged('payment-gateways');
        </div>
        <div class="text">
            Проблема "Толстых" Моделей <br />
            В типичном Laravel-приложении логика часто пишется прямо в контроллерах или моделях, что приводит к:<br />
            Сложности тестирования.<br />
            Нарушению Single Responsibility Principle (SRP).<br />
            Трудностям при замене источника данных (например, с MySQL на API).<br />
            Решение: Репозиторий-паттерн<br />
            Репозиторий — это прослойка между бизнес-логикой и данными.<br />
        </div>
        <div class="code">
            interface UserRepositoryInterface {
                public function find(int $id): ?User;
                public function save(User $user): void;
                public function findByEmail(string $email): ?User;
            }

            class EloquentUserRepository implements UserRepositoryInterface {
                public function find(int $id): ?User {
                    return User::find($id);
                }

                public function save(User $user): void {
                    $user->save();
                }

                public function findByEmail(string $email): ?User {
                    return User::where('email', $email)->first();
                }
            }

            // Внедрение репозитория через DI
            // В сервис-провайдере:
            $this->app->bind(
                UserRepositoryInterface::class,
                EloquentUserRepository::class
            );

            // В контроллере:
            class UserController {
                public function __construct(
                    protected UserRepositoryInterface $users
                ) {}

                public function show(int $id) {
                    return $this->users->find($id);
                }
            }
        </div>
        <div class="text">
            В Laravel bind и singleton — это два метода регистрации зависимостей в Service Container, но они работают по-разному <br />
            bind() — Обычная привязка - Создает новый экземпляр при каждом обращении к контейнеру <br />
            singleton() — Одиночка - Возвращает один и тот же экземпляр при всех последующих вызовах.<br />
            bind()	Новый каждый раз	+	Запросы, уникальные контексты <br />
            singleton()	Один на все вызовы	–	Общие ресурсы (БД, конфиги)
        </div>
        <div class="code">
            // Bind
            $this->app->bind(MyService::class, function ($app) {
                return new MyService();
            });

            // Каждый раз новый объект
            $service1 = app(MyService::class); // Новый экземпляр
            $service2 = app(MyService::class); // Еще один новый экземпляр
            var_dump($service1 === $service2); // false

            // Проверка типа привязки
            dd(app()->bound(MyService::class)); // true/false
            dd(app()->isShared(MyService::class)); // true для singleton
            -----------------------------------------------
            // Singleton
            $this->app->singleton(MyService::class, function ($app) {
                return new MyService();
            });

            // Всегда один объект
            $service1 = app(MyService::class); // Создан впервые
            $service2 = app(MyService::class); // Возвращен тот же экземпляр
            var_dump($service1 === $service2); // true
            // проверка
            $this->app->instance(MyService::class, new FakeService());

        </div>
    </main>
</body>
</html>

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHP</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <header>
        <nav>
            <ul>
                <li><a href="../index.html">Home</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <h1>PHP</h1>
        
        <section class="blog">
            <article class="post">
                <h2>Классы и обьекты</h2>
                <p>Большую часть написанного кода на РНР можно встроить непосредственно в
                    разметку веб- страниц, потому что для этого в РНР предусмотрена соответствующая поддержка.</p>
                    <p>РНР 7, выпущенной в декабре 2015 года. В частности, в этой версии поддерживаются объявления типов
                    параметров и возвращаемых типов</p>
                    <p>В декабре 2020 года, почти через пять лет после выпуска РНР 7, был
                        подготовлен к выпуску РНР 8.</p>
                    <p>Объекты не всегда были основной частью РНР- проекта. Более того,
                        идея реализовать объекты пришла в голову разработчикам РНР в виде 
                        запоздалой мысли.</p>
                    <p>Своим происхождением язык РНР, каким мы его знаем сегодня, 
                        обязан двум инструментальным средствам, которые разработал Расмус 
                        Лердорф на языке Perl. Сокращение “РНР” обозначало “ Personal Home Page
                        Tools” ( Средства для персональной начальной страницы ), a “ FI” “ Form
                        Interpreter” ( Интерпретатор форм ).</p>
                    <p>Для расширения возможностей языка РНР был заново
                        написан процессор Zend, название которого происходит от имен Zeev и
                        Andi . Процессор Zend стал одним из основных компонентов, положенных
                        в основу работы РНР.</p>
                    <p><img src="./image/php/php1.png"></p>
                    <p>Несмотря на то что такая конструкция действовала исправно, программисты
                         часто забывали добавить символ амперсанда, и вероятность появления
                         ошибок в объектно -ориентированном коде была очень высока.</p>
                    <p>В версии РНР 5.3 были введены пространства имен. Это по-
                        зволило создавать именованные области видимости для классов и функций,
                         в результате чего снизилась вероятность дублирования имен при
                        включении компонентов в библиотеки и расширении системы</p>
                    <p>Класс — это шаблон кода, применяемый для создания
                        объектов. Класс объявляется с помощью ключевого слова class и произвольного имени класса.</p>
                        <p><img src="./image/php/php2.png"></p>
                    <p>В версиях РНР 4 и РНР 5 (до версии 5.1 включительно) объекты
                        можно выводить на печать непосредственно. В итоге объект будет приведен
                        к символьной строке, содержащей его идентификатор. Но, начиная с версии
                        РНР 5.2, такая возможность больше не поддерживается , и любая попытка интерпретировать 
                        объект как символьную строку приведет к ошибке, если только 
                        в классе этого объекта не будет определен метод toString ()</p>
                    <p>В классах можно определять свойства и методы, свойства можно передоваать в 
                        конструкторе класса, мнтод отличается от функции тем что он определяется в теле класса
                    </p>
                    <p>Как и свойства, методы можно определять
                        как public, protected или private. Объявляя метод как public, мы тем
                        самым обеспечиваем возможность его вызова за пределами текущего объ-
                        екта. Если в определении метода опустить ключевое слово, определяющее
                        область его видимости, то метод будет объявлен как public неявно.</p>
                    <p><img src="./image/php/php3.png"></p>
                    <p>Метод конструктора вызывается при создании объекта. Он служит
                        для настройки экземпляра объекта, установки определенных значений
                        его свойств и выполнения всей подготовительной работы к применению
                        объекта.</p>
                    <p>До версии РНР 5 имя метода-конструктора совпадало с име-
                        нем класса, к которому оно относилось . Так, в качестве конструктора класса
                        ShopProduct можно было использовать метод ShopProduct ( ) . Такой синтаксис
                        считается устаревшим, начиная с версии РНР 7, и вообще не работает в версии РНР 8.
                        Метод-конструктор следует именовать
                        __construct().</p>
                    <p><img src="./image/php/php4.png"></p>
                    <p><img src="./image/php/php5.png"></p>
                    <p><img src="./image/php/php6.png"></p>
                    <p><img src="./image/php/php7.png"></p>
                    <p><img src="./image/php/php8.png"></p>
                    <p><img src="./image/php/php9.png"></p>
                    <p>Если аргумент не обьязательный то можно использовать эту конструкцию
                        <kbd>public function getValues(array $default = null)</kbd> Если значение типа может быть null
                    то можно использовать такую конструкцию <kbd>public function add(?string $value)</kbd></p>
                    <p>Смешанный тип можно определить так mixed, или вот так int|fload</p>
                    <p><img src="./image/php/php10.png"></p>
                    <p>Наследование
                        — это механизм, посредством которого один или несколь-
                        ко классов можно получить из некоторого базового класса. Класс, унаследованный от другого класса,
                         называется его подклассом. Эта связь обычно
                        описывается с помощью терминов родительский и дочерний, дочерний класс расширяет родительский.
                    Наследование происходит ключевым словом extends. Определяя конструктор в дочернем классе, вы берете на себя ответствен-
                    ность за передачу требующихся аргументов родительскому классу.
                    Синтаксическая конструкция parent :: construct() означает следующее: “Вызвать метод construct () из
                     родительского класса”</p>
                    <p><img src="./image/php/php11.png"></p>
                    <p>Ключевое слово parent можно использовать в любом методе, перекры-
                        вающем свой эквивалент из родительского класса. Когда метод перекрывается, 
                        вероятнее всего, требуется расширить, а не отменить функциональные возможности родительского класса. Достичь этого можно,</p>
                    <p>Элементы класса можно объявить как public ( открытые), private ( закрытые ) или protected ( защищенные )
                        <br/>• К открытым свойствам и методам можно получать доступ из любого контекста.
                        <br/>• К закрытому свойству и методу можно получить доступ только из
                        того класса, в котором они объявлены. Даже подклассы данного клас-
                        са не имеют доступа к таким свойствам и методам.
                        <br/>• К защищенным свойствам и методам можно получить доступ либо
                        из содержащего их класса, либо из его подкласса. Никакому внешнему коду такой доступ не предоставляется.
                    </p>
                    <p>Свойства класса тоже можно типизировать</p>
                    <p><img src="./image/php/php12.png"></p>
                    <p>Доступ к методам и свойствам можно получать в контексте класса, а не объекта. 
                        Такие методы и свойства являются статическими и должны быть объявлены с помощью ключевого
                        слова static</p>
                    <p><img src="./image/php/php13.png"></p>
                    <p><img src="./image/php/php14.png"></p>
                    <p>Статические методы это функции, применяемые в контексте класса.
                        Они не могут сами получать доступ к обычным свойствам класса, потому что такие свойства относятся к объектам.
                         Но из статических методов
                        можно обращаться к статическим свойствам</p>
                    <p>PDO означает РНР Data Object ( Объект данных РНР ).
                        А класс PDO обеспечивает универсальный интерфейс для различных приложений баз данных.</p>
                    <p>Термин фабрика относится к коду, предназначенному для создания экземпляров объектов
                        Постоянное свойство объявляется с помощью ключевого
                        слова const. В отличие от обычных свойств перед именем константного
                        свойства не ставится знак доллара. Для них зачастую принято выбирать
                        имена, состоящие только из прописных букв, как в следующем примере: <kbd>const OUT OF STOCK = 1;</kbd>
                    </p>
                    <p>Абстрактный класс отличается тем, что невозможно создать его 
                        экземпляр. Вместо этого в нем определяется ( и, возможно, частично 
                        реализуется ) интерфейс для любого класса, который может его расширить.
                        Абстрактный класс определяется с помощью ключевого слова abstract.</p>
                    <p>Как известно, в абстрактном классе допускается реализация некоторых
                        методов , не объявленных абстрактными. В отличие от них, интерфейсы
                        это чистые шаблоны. С помощью интерфейса можно только определить
                        функциональность, но не реализовать ее. Для объявления интерфейса 
                        используется ключевое слово interface</p>
                    <p>Реализующий класс принимает тип класса и интерфейса, который он расширяет.
                        Реализация интерфейса в классе <kbd>class Shipping implements Chargeable</kbd>
                    </p>
                    <p>В отличие от языка C++, в РНР, как и в языке Java, не поддерживается
                        множественное наследование. Но эту проблему можно частично решить с
                        помощью интерфейсов, как было показано в предыдущем разделе. Иными
                        словами, для каждого класса в РНР может существовать только один родительский
                         класс. Тем не менее в каждом классе можно реализовать произвольное
                         количество интерфейсов. При этом данный класс будет принимать
                         типы всех тех интерфейсов, которые в нем реализованы. 
                         Но что делать, если требуется реализовать ряд общих
                         методов для всей иерархии наследования классов ? Для этой цели в версии
                         РНР 5.4 было введено понятие трейтов</p>
                         <p><img src="./image/php/php15.png"></p>
                         <p><img src="./image/php/php16.png"></p>
                         <p>В PHP можно разрешить конфликты имён в трейтах с помощью оператора insteadof и as.</p>
                         <p><img src="./image/php/php17.png"></p>
                         <p><img src="./image/php/php18.png"></p>
                         <p>Абстрактные методы можно объявлять в трейтах так же, как и в 
                            обычных классах. Чтобы воспользоваться таким трейтом в классе, в нем следует
                            реализовать все объявленные в трейте абстрактные методы.</p>
                        <p>Безусловно, ничто не может помешать вам объявить методы 
                            трейта открытыми ( public ), защищенными ( private ) или закрытыми
                            ( protected ). Но вы можете изменить эти модификаторы доступа к 
                            методам и непосредственно в том классе, в котором используется трейт</p>
                        <p>При обработки ошибок можно использовать эти методы</p>
                        <p><img src="./image/php/php19.png"></p>
                        <p><img src="./image/php/php20.png"></p>
                        <p>обработку ошибок можно писать в конструкции try catch finally
                            Блок finally выполняется, если в блоке catch повторно генерируется
                            исключение или выполняется оператор return, возвращающий
                            значение вызывающему коду. Если же в блоке try или catch для завершения
                            сценария вызывается функция die() или exit(), то блок finally не выполняется.
                        </p>
                        <p>В PHP можно создавать собственные исключения, расширяя встроенный класс Exception, и затем использовать их в try-catch блоках.</p>
                        <p><img src="./image/php/php21.png"></p>
                        <p><img src="./image/php/php22.png"></p>
                        <p>Если вы создали необходимый уровень функцио-
                            нальности для класса и считаете, что его переопределение может только
                            повредить идеальной работе программы, воспользуйтесь ключевым словом final
                            Ключевое слово final позволяет положить конец наследованию. Для
                            завершенного класса нельзя создать подкласс, 
                            методы тоже бывают завершенными и завершенный метод нельзя перекрыть. <kbd>final class Checkout</kbd></p>
                            <p>Методы перехватчики или как их еще называют магические методы вызываются неявно и бывают этих типов</p>
                            <p><img src="./image/php/php23.png"></p>
                            <p>В версии РНР 5 в
                                язык был добавлен метод -деструктор __destruct() , который вызыва-
                                ется непосредственно перед тем, как объект отправляется на “ свалку”, т.е.
                                удаляется из памяти. Этим методом можно пользоваться для выполнения
                                завершающей очистки оперативной памяти от объектов, если в этом есть
                                необходимость.</p>
                            <p>В PHP метод __clone() позволяет определить поведение при клонировании объекта с помощью clone</p>
                            <p><img src="./image/php/php24.png"></p>
                            <p><img src="./image/php/php25.png"></p>
                            <p>Еще одним языковым средством, внедренным в версии РНР 5 явно под
                                влиянием Java, является метод toString ( ) . До выхода версии РНР 5.2
                                при выводе объекта он разрешался в строку:</p>
                            <p><img src="./image/php/php26.png"></p>
                            <p>Функция обратного вызова (callback) — это блок выполнимого
                                кода, который можно сохранить в переменной или передать методам и функциям
                                для последующего вызова<br/>
                                Callback – функция, передаваемая в другую функцию.<br/>
                                Анонимная функция – функция без имени, которую можно передавать как колбэк.
                                </p>
                            <p>Callback – это функция, которую передают в качестве аргумента другой функции и вызывают внутри неё.</p>
                            <p><img src="./image/php/php27.png"></p>
                            <p>Анонимная функция (lambda, замыкание) – это функция без имени. 
                                Она может быть присвоена переменной или передана как аргумент.</p>
                            <p><img src="./image/php/php28.png"></p>
                            <p>Callback + Анонимная функция</p>
                            <p><img src="./image/php/php29.png"></p>
                            <p>Анонимный класс – это класс без имени, который создаётся прямо в момент его использования.
                                Он обычно используется, когда нужно создать одноразовый объект без необходимости объявлять
                                полноценный класс.</p>
                            <p><img src="./image/php/php30.png"></p>
                            <p><img src="./image/php/php31.png"></p>
                            <p><img src="./image/php/php32.png"></p>
            </article>

        </section>
        
    </main>

</body>
</html>

const lessons = [
    {
        title: 'Математика 5 класс глава 1',
        content: `1,2,3,4,5,6,7,8,9,10,11,12... называются натуральными числами, 1/2 не натуральное число<br/>
        Рядом натуральных чисел называют натуральные числа в порядке возрастания, наименьшее натуральное число это 1 наибольшего нет<br/>
        Есть 10 цифр из них строятся числа (1,2,3,4,5,6,7,8,9,0), все числа кроме однозначных можно называть многозначными<br/>
        большие числа можно поделить на классы 17(миллионы) 450(тысячи) 124(единицы), каждый класс в свою очередь разделяется на <br/>
        единицы, десятки и сотни <img src='./images/algebra/1.png'/>
        Пример отрезка <img src='./images/algebra/2.png'/> длину отрезка можно измерять милиметрами, сантиметрами, дециметрами<br/>
        метрами и километрами, измерить отрезок это подщитать сколько единичных отрезков в нем помещяются<br/>
        Два отрезка считаются равными если при наложении друг на друга их длина одинакова<br/>
        Прямая это геометрическая фигура которая не имеет концов, у луча есть начало но нет конца
        <img src='./images/algebra/3.png'/>
        <img src='./images/algebra/4.png'/>`
    },
    {
        title: 'PHP Zandstra',
        content: `В PHP 7 было введено обьявление скалярных типов данных, а так же анонимных классов<br/>
        Класс это шаблон кода для создания обьектов
        <img src='./images/php/1.png'/>
        В php 4 и 5.1 можно выводить классы непосредственным путем но начиная с php 5.2 нужно добавить метод __toString()<br/>
        private, protected и public определяют оюласть кода для которого метод будет доступным
        <img src='./images/php/2.png'/>
        Передавать значения вышеуказаным способом не принятая практика, потому что создавая класс мы подразумеваем что у него уже есть<br/>
        свойство title<br/>
        В отличии от функции методы обьявляются внутри класса
        <img src='./images/php/3.png'/>
        public - открытый можно использовать за пределами класса<br/>
        Метод __construct вызывается при создании экземпляра класса, как и __toString() это магический метод, до php 5 метод __construct<br/>
        совпадал с именем класса, в php 8 обьявлять свойства можно в конструкторе<br/>
        <img src='./images/php/4.png'/>`
    },
    {
        title: 'PHP & Lighthouse',
        content: `Для установки можно воспользоваться официальным сайтом lighthouse-php.com, внутри laravel <br/>
        создасться директория graphql с файлом schema.graphql <br/>
        php artisan vendor:publish --tag=lighthouse-config в папке config создаст файл lighthouse.php с настройками graphql для laravel
        <img src='./images/php/5.png'/>
        ВОсклицательный знак означает required`
    },
    {
        title: 'Computer science',
        content: `Алгоритм белого списка (White List) — это подход, при котором разрешаются только заранее определённые и<br/>
        проверенные значения (например, данные, действия, IP-адреса или маршруты). Всё, что не входит в список, автоматически блокируется.
        <img src='./images/php/6.png'/>`
    },
    {
        title: 'PHP Zandstra',
        content: `В PHP 8 появились именованные аргкменты для методов
        <img src='./images/php/7.png'/>
        Для проверки типов данных использутся функции которые возвращают true/false
        <img src='./images/php/8.png'/>
        <img src='./images/php/9.png'/>
        С 5-й версии php были добавлены обьявления типов данных для методов, если не следовать канонам типизации то получим TypeError<br/>
        Если нужно создать необьязательный аргумент то можно воспользоваться следующим кодом function test(array $arr = null)<br/>
        php 8 - mixed означает смешанные типы данных
        <img src='./images/php/10.png'/>
        До php 8 обьявления переменных с несколькоми типами можно было сделать только в теле метода тепер это можно сделать так int|string|float<br/>
        Если переменная может получить тип null то ее можно определить следующим образом function test(string ?$arg)<br/>
        Можно обьявить тип возвращающего значения function test(string ?$arg): int<br/>
        Тип void возвращает ничего<br/>
        Наследование позволяет создовать несколько классов из одного базового`
    },
    {
        title: 'PHP & Lighthouse',
        content: `Schema похожа на схему в базах данных она описывает данные, есть 3 корневые типы Query, mutation и Subscription<br/>
        Scalar это определенные в type-ах значения типо int, string Id и так далее<br/>
        $carbon->diffForHumans() возвратит время как 38 minutes ago<br/>
        Определения скаляров можно таким образом
        <img src='./images/php/11.png'/>
        Директивы это очень мощный инструмент lighthouse
        <img src='./images/php/12.png'/>`
    },
    {
        title: 'Computer science',
        content: `Алгоритм бинарного поиска Объяснение работы: Массив должен быть отсортирован. Бинарный поиск работает только<br/>
        с отсортированными данными. Идея алгоритма: Делим массив на две половины. Сравниваем искомое число ($target) со<br/>
        средним элементом: Если совпадает — возвращаем индекс. Если меньше — продолжаем поиск в левой половине.<br/>
        Если больше — продолжаем поиск в правой половине. Повторяем до нахождения элемента или завершения диапазона.<br/>
        <img src='./images/php/13.png'/>`
    },
    {
        title: 'PHP Zandstra',
        content: `Класс наследованный от другого класса называется подклассом, как правило дочерний класс расширяет функционал родительского класса<br/>
        $someClass instanceof MainClass - instanceof возвращает true или false если переменная является обьектом MainClass<br/>
        ChildClass extends ParentClass оператор extends отвечает за наследования, при создании дочернего класса будет вызываться так<br/>
        же констрктор родительского класса, каждый класс наследует свойства родительского класса и может расширять и менять эти свойства<br/>
        Вот как выглядит расширения сврйств конструктора дочернего класса 
        <img src='./images/php/14.png'/>
        public можно получить доступ из любого контекста<br/>
        protected доступ только внутри класса и подклассов <br/>
        private доступ только внутри класса, даже подклассы не имеют доступа к таким методам и свойствам<br/>
        Доступ к методам и свойствам можно получать в контексте класса, а не объекта. Такие методы и свойства являются<br/>
        статическими и должны быть объявлены с помощью ключевого
        слова static`
    },

    {
        title: 'PHP Zandstra',
        content: `Доступ к статистическому свойству осуществляется через класс а не через экземпляр обьекта ClassName::staticMethod()<br/>
        Чтобы получить доступ к статическому методу или свойству из того же самого класса ( а не из дочернего класса ),<br/>
        мы пользуемся ключевым словом self. Ключевое слово self служит для обращения к текущему классу подобно<br/>
        тому, как псевдопеременная $this к текущему объекту.
        <img src='./images/php/15.png'/>
        Полезность статических методов и свойств Во- вторых, статическое свойство доступно каждому экземпляру объекта данного класса<br/>
        Поэтому так можно определить значения, которые должны быть доступны всем объектам данного типа. И, наконец, благодаря тому<br/>
        что отпадает необходимость в наличии экземпляра класса для доступа к его статическому свойству или методу, можно<br/>
        избежать создания экземпляров объектов исключительно ради вызова простой функции<br/>
        PDO означает РНР Data Object ( Объект данных РНР ). А класс PDO обеспечивает универсальный интерфейс для различных<br/>
        приложений баз данных.<br/>
        Термин фабрика относится к коду, предназначенному для создания экземпляров объектов<br/>
        const TEST_TEST = 37; постоянное свойство которое нельзя изменить, всегда примитивные значения<br/>
        Абстрактный класс отличается тем, что невозможно создать его экземпляр. Вместо этого в нем определяется ( и, возможно<br/>
        частично реализуется ) интерфейс для любого класса, который может его расширить.
        Как правило, в абстрактном классе должен содержаться по меньшей мере один абстрактный метод. Как и абстрактный класс<br/>
        он объявляется с помощью ключевого слова abstract. Абстрактный метод не может быть реализован в абстрактном классе.<br/>
        Он объявляется как обычный метод, но объявление завершается точкой с запятой, а не телом метода
        <img src='./images/php/16.png'/>
        В отличии от абстрактных классов где возможна некоторая реализация методов интерфейсы являются полными шаблонами
        <img src='./images/php/17.png'/>
        Class Test implements Chargable {}<br/>
        В php только одиночное наследование поэтому после слово extends пишем один класс но после implements можем добавить много интерфейсов<br/>
        class Consultancy extends TimedService implements Bookable, Chargeable {}`
    },
];

let lessonsHtml = '<div>';
const mainElement = document.querySelector('main');
let lessonCount = 0;

lessons.forEach(lesson => {
    lessonCount += 1;
    lessonsHtml += `
        <div class='lesson'>
            <h3>${lesson.title}</h3>
            <p>${lesson.content}</p>
            <p><b>-${lessonCount}-</b></p>
        </div>
    `
});

lessonsHtml += '</div>';
mainElement.innerHTML = lessonsHtml;
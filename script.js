let lessons = [
    {
        meta_title: 'algebra',
        title: 'Математика 5 класс глава 1',
        content: `1,2,3,4,5,6,7,8,9,10,11,12... называются натуральными числами, 1/2 не натуральное число<br/>
        Рядом натуральных чисел называют натуральные числа в порядке возрастания, наименьшее натуральное число это 1 наибольшего нет<br/>
        Есть 10 цифр из них строятся числа (1,2,3,4,5,6,7,8,9,0), все числа кроме однозначных можно называть многозначными<br/>
        большие числа можно поделить на классы 17(миллионы) 450(тысячи) 124(единицы), каждый класс в свою очередь разделяется на <br/>
        единицы, десятки и сотни <img src='./images/algebra/1.png'/>
        Пример отрезка <img src='./images/algebra/2.png'/> длину отрезка можно измерять милиметрами, сантиметрами, дециметрами<br/>
        метрами и километрами, измерить отрезок это подщитать сколько единичных отрезков в нем помещяются<br/>
        Два отрезка считаются равными если при наложении друг на друга их длина одинакова<br/>
        Прямая это геометрическая фигура которая не имеет концов, у луча есть начало но нет конца
        <img src='./images/algebra/3.png'/>
        <img src='./images/algebra/4.png'/>`
    },
    {
        meta_title: 'php',
        title: 'PHP Zandstra',
        content: `В PHP 7 было введено обьявление скалярных типов данных, а так же анонимных классов<br/>
        Класс это шаблон кода для создания обьектов
        <img src='./images/php/1.png'/>
        В php 4 и 5.1 можно выводить классы непосредственным путем но начиная с php 5.2 нужно добавить метод __toString()<br/>
        private, protected и public определяют оюласть кода для которого метод будет доступным
        <img src='./images/php/2.png'/>
        Передавать значения вышеуказаным способом не принятая практика, потому что создавая класс мы подразумеваем что у него уже есть<br/>
        свойство title<br/>
        В отличии от функции методы обьявляются внутри класса
        <img src='./images/php/3.png'/>
        public - открытый можно использовать за пределами класса<br/>
        Метод __construct вызывается при создании экземпляра класса, как и __toString() это магический метод, до php 5 метод __construct<br/>
        совпадал с именем класса, в php 8 обьявлять свойства можно в конструкторе<br/>
        <img src='./images/php/4.png'/>`
    },
    {
        meta_title: 'php',
        title: 'PHP & Lighthouse',
        content: `Для установки можно воспользоваться официальным сайтом lighthouse-php.com, внутри laravel <br/>
        создасться директория graphql с файлом schema.graphql <br/>
        php artisan vendor:publish --tag=lighthouse-config в папке config создаст файл lighthouse.php с настройками graphql для laravel
        <img src='./images/php/5.png'/>
        ВОсклицательный знак означает required`
    },
    {
        meta_title: 'add_techno',
        title: 'Computer science',
        content: `Алгоритм белого списка (White List) — это подход, при котором разрешаются только заранее определённые и<br/>
        проверенные значения (например, данные, действия, IP-адреса или маршруты). Всё, что не входит в список, автоматически блокируется.
        <img src='./images/php/6.png'/>`
    },
    {
        meta_title: 'php',
        title: 'PHP Zandstra',
        content: `В PHP 8 появились именованные аргкменты для методов
        <img src='./images/php/7.png'/>
        Для проверки типов данных использутся функции которые возвращают true/false
        <img src='./images/php/8.png'/>
        <img src='./images/php/9.png'/>
        С 5-й версии php были добавлены обьявления типов данных для методов, если не следовать канонам типизации то получим TypeError<br/>
        Если нужно создать необьязательный аргумент то можно воспользоваться следующим кодом function test(array $arr = null)<br/>
        php 8 - mixed означает смешанные типы данных
        <img src='./images/php/10.png'/>
        До php 8 обьявления переменных с несколькоми типами можно было сделать только в теле метода тепер это можно сделать так int|string|float<br/>
        Если переменная может получить тип null то ее можно определить следующим образом function test(string ?$arg)<br/>
        Можно обьявить тип возвращающего значения function test(string ?$arg): int<br/>
        Тип void возвращает ничего<br/>
        Наследование позволяет создовать несколько классов из одного базового`
    },
    {
        meta_title: 'php',
        title: 'PHP & Lighthouse',
        content: `Schema похожа на схему в базах данных она описывает данные, есть 3 корневые типы Query, mutation и Subscription<br/>
        Scalar это определенные в type-ах значения типо int, string Id и так далее<br/>
        $carbon->diffForHumans() возвратит время как 38 minutes ago<br/>
        Определения скаляров можно таким образом
        <img src='./images/php/11.png'/>
        Директивы это очень мощный инструмент lighthouse
        <img src='./images/php/12.png'/>`
    },
    {
        meta_title: 'add_techno',
        title: 'Computer science',
        content: `Алгоритм бинарного поиска Объяснение работы: Массив должен быть отсортирован. Бинарный поиск работает только<br/>
        с отсортированными данными. Идея алгоритма: Делим массив на две половины. Сравниваем искомое число ($target) со<br/>
        средним элементом: Если совпадает — возвращаем индекс. Если меньше — продолжаем поиск в левой половине.<br/>
        Если больше — продолжаем поиск в правой половине. Повторяем до нахождения элемента или завершения диапазона.<br/>
        <img src='./images/php/13.png'/>`
    },
    {
        meta_title: 'php',
        title: 'PHP Zandstra',
        content: `Класс наследованный от другого класса называется подклассом, как правило дочерний класс расширяет функционал родительского класса<br/>
        $someClass instanceof MainClass - instanceof возвращает true или false если переменная является обьектом MainClass<br/>
        ChildClass extends ParentClass оператор extends отвечает за наследования, при создании дочернего класса будет вызываться так<br/>
        же констрктор родительского класса, каждый класс наследует свойства родительского класса и может расширять и менять эти свойства<br/>
        Вот как выглядит расширения сврйств конструктора дочернего класса 
        <img src='./images/php/14.png'/>
        public можно получить доступ из любого контекста<br/>
        protected доступ только внутри класса и подклассов <br/>
        private доступ только внутри класса, даже подклассы не имеют доступа к таким методам и свойствам<br/>
        Доступ к методам и свойствам можно получать в контексте класса, а не объекта. Такие методы и свойства являются<br/>
        статическими и должны быть объявлены с помощью ключевого
        слова static`
    },

    {
        meta_title: 'php',
        title: 'PHP Zandstra',
        content: `Доступ к статистическому свойству осуществляется через класс а не через экземпляр обьекта ClassName::staticMethod()<br/>
        Чтобы получить доступ к статическому методу или свойству из того же самого класса ( а не из дочернего класса ),<br/>
        мы пользуемся ключевым словом self. Ключевое слово self служит для обращения к текущему классу подобно<br/>
        тому, как псевдопеременная $this к текущему объекту.
        <img src='./images/php/15.png'/>
        Полезность статических методов и свойств Во- вторых, статическое свойство доступно каждому экземпляру объекта данного класса<br/>
        Поэтому так можно определить значения, которые должны быть доступны всем объектам данного типа. И, наконец, благодаря тому<br/>
        что отпадает необходимость в наличии экземпляра класса для доступа к его статическому свойству или методу, можно<br/>
        избежать создания экземпляров объектов исключительно ради вызова простой функции<br/>
        PDO означает РНР Data Object ( Объект данных РНР ). А класс PDO обеспечивает универсальный интерфейс для различных<br/>
        приложений баз данных.<br/>
        Термин фабрика относится к коду, предназначенному для создания экземпляров объектов<br/>
        const TEST_TEST = 37; постоянное свойство которое нельзя изменить, всегда примитивные значения<br/>
        Абстрактный класс отличается тем, что невозможно создать его экземпляр. Вместо этого в нем определяется ( и, возможно<br/>
        частично реализуется ) интерфейс для любого класса, который может его расширить.
        Как правило, в абстрактном классе должен содержаться по меньшей мере один абстрактный метод. Как и абстрактный класс<br/>
        он объявляется с помощью ключевого слова abstract. Абстрактный метод не может быть реализован в абстрактном классе.<br/>
        Он объявляется как обычный метод, но объявление завершается точкой с запятой, а не телом метода
        <img src='./images/php/16.png'/>
        В отличии от абстрактных классов где возможна некоторая реализация методов интерфейсы являются полными шаблонами
        <img src='./images/php/17.png'/>
        Class Test implements Chargable {}<br/>
        В php только одиночное наследование поэтому после слово extends пишем один класс но после implements можем добавить много интерфейсов<br/>
        class Consultancy extends TimedService implements Bookable, Chargeable {}`
    },
    {
        meta_title: 'php',
        title: 'PHP & Lighthouse',
        content: `Директива @all выбирет все данные из модели
        <img src='./images/php/18.png'/>`
    },
    {
        meta_title: 'php',
        title: 'Laravel Documentation',
        content: `Можно установить установщик ларавел composer global require laravel/installer и после устанавливать новые проекты<br/>
        таким образом laravel new example-app<br/>
        Все файлы конфигурации Laravel хранятся в каталоге config<br/>
        важные параметры конфигурации задаются в файле .env<br/>
        Файл .env не следует добавлять в систему контроля версий вашего приложения, так как различные разработчики и серверы могут<br/>
        требовать разные настройки окружения<br/>
        php artisan migrate после создания проекта выполнит все необходимые миграции`
    },
    {
        meta_title: 'add_techno',
        title: 'Computer science',
        content: `Алгоритм сортировки вставкой работает так: Разделяем массив: считаем, что первый элемент уже отсортирован.<br/>
        Берём следующий элемент и сравниваем с предыдущими. Сдвигаем элементы, которые больше текущего, вправо.<br/>
        Вставляем текущий элемент на его правильное место. Повторяем, пока весь массив не станет отсортированным.<br/>
        Пример работы: Для массива [5, 2, 9, 1]: Сначала [5] — отсортировано. 2 < 5 → сдвигаем 5 и вставляем 2: [2, 5].<br/>
        9 > 5 → оставляем как есть: [2, 5, 9]. 1 < 2 → сдвигаем все вправо и вставляем 1: [1, 2, 5, 9].<br/>
        Это просто и эффективно для маленьких массивов.
        <img src='./images/php/19.png'/>
        Сортировка вставкой полезна, когда: Массив небольшой (до ~10-20 элементов) — алгоритм работает быстро, так как не<br/>
        требует много операций. Массив почти отсортирован — если элементы уже близки к нужному порядку, сортировка вставкой работает<br/>
        очень эффективно. Недостатки: Для больших массивов алгоритм медленный, так как имеет сложность Не подходит для сортировки<br/>
        больших данных. Если хочешь производительности, лучше использовать быструю сортировку или сортировку слиянием.`
    },
    {
        meta_title: 'go',
        title: 'Go',
        content: `Полезен для создания веб сервисов, файлы имеют расширение .go`
    },
     {
        meta_title: 'php',
        title: 'PHP Zandstra',
        content: `Трейты похожи на классы, экземпляры которых нельзя получить, но можно включить в другие классы<br/>
        Внутри класса нужно прописать use TraitName для доступа к методам трейта<br/>
        методы интерфейса могут быть удовлетварены и выполнены в трейтах, трейт не меняет тип класса а интерфейс меняет
        <img src='./images/php/20.png'/>
        Если одноименный метод использован в двух трейтах то используется слово insteadof или as
        <img src='./images/php/21.png'/>
        В трейтах можно определять абстрактные методы и в таком случае мы будем вынуждены реализовать их в классах где трейт используется<br/>
        Можно поменять модификаторы доступа для методов трейта внутри самого класса 
        <img src='./images/php/22.png'/>`
    },
    {
        meta_title: 'php',
        title: 'PHP & Lighthouse',
        content: `Пример создания запроса на единичного и множество пользователей 
        <img src='./images/php/23.png'/>`
    },
    {
        meta_title: 'php',
        title: 'Laravel Documentation',
        content: `Все конфигурационные файлы фреймворка Laravel хранятся в каталоге config, Конфигурационные файлы позволяют<br/>
        настраивать такие вещи, как информация о подключении к базе данных, информация о почтовом сервере, а также другие основные<br/>
        параметры, например, часовой пояс приложения и ключ шифрования<br/>
        php artisan about - может отображать обзор конфигурации (php artisan about --only=environment)<br/>
        php artisan config:show database - чтобы получить детальную информацию о значениях в определенном файле конфигурации<br/>
        Текущее окружение приложения определяется с помощью переменной APP_ENV из файла .env
        <img src='./images/php/24.png'/>
        php artisan env:encrypt - Для шифрования файла окружения (php artisan env:decrypt)<br/>
        Значения конфигураций можно использовать таким образом Config::get('app.timezone'), Config::set('app.timezone', 'America/Chicago')<br/>
        php artisan config:cache - кеширует настройки (php artisan config:clear)<br/>
        Большинство файлов конфигурации Laravel уже опубликованы в каталоге config вашего приложения<br/>
        однако некоторые файлы конфигурации, такие как cors.php и view.php, не публикуются по умолчанию<br/>
        поскольку большинству приложений никогда не потребуется их модифицировать.Однако вы можете использовать Artisan-команду<br/>
        config:publish для публикации любых файлов конфигурации, которые не публикуются по умолчанию: php artisan config:publish<br/>
        Чтобы включить режим обслуживания, выполните команду down Artisan: php artisan down (php artisan up)`
    },
    {
        meta_title: 'ruby',
        title: 'Ruby',
        content: `Файлы руби имеют расширение .rb, p или puts выводит на экран данные как echo в php<br/>
        ruby filename.rb для запуска файла на ruby`
    },
];

lessons.sort((a, b) => {
    if (a.title < b.title) {
        return -1;
    }
    if (a.title > b.title) {
        return 1;
    }
    return 0;
});


let lessonsHtml = '<div>';
const mainElement = document.querySelector('main');
let lessonCount = 0;

lessons.forEach(lesson => {
    lessonCount += 1;
    lessonsHtml += `
        <div class='lesson'>
            <h3>${lesson.title}</h3>
            <p>${lesson.content}</p>
            <p><b>-${lessonCount}-</b></p>
        </div>
    `
});

lessonsHtml += '</div>';
mainElement.innerHTML = lessonsHtml;

document.querySelectorAll('.menu-item').forEach(item => {
    item.addEventListener('click', () => {
        mainElement.innerHTML = '';

        let lessonsHtml = '';
        let lessonCount = 0;

        const filterTitle = item.id;
        const filteredData = lessons.filter(obj => obj.meta_title === filterTitle);

        filteredData.forEach(lesson => {
            lessonCount += 1;
            lessonsHtml += `
                <div class='lesson'>
                    <h3>${lesson.title}</h3>
                    <p>${lesson.content}</p>
                    <p><b>-${lessonCount}-</b></p>
                </div>
            `;
        });

        mainElement.innerHTML = lessonsHtml;
    });
});


document.querySelectorAll('img').forEach(img => {
    img.addEventListener('click', () => {
        if (img.style.width === '80%') {
            img.style.width = '10%';
        } else {
            img.style.width = '80%';
        }
    });
});

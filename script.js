const lessons = [
    {
        title: 'Математика 5 класс глава 1',
        content: `1,2,3,4,5,6,7,8,9,10,11,12... называются натуральными числами, 1/2 не натуральное число<br/>
        Рядом натуральных чисел называют натуральные числа в порядке возрастания, наименьшее натуральное число это 1 наибольшего нет<br/>
        Есть 10 цифр из них строятся числа (1,2,3,4,5,6,7,8,9,0), все числа кроме однозначных можно называть многозначными<br/>
        большие числа можно поделить на классы 17(миллионы) 450(тысячи) 124(единицы), каждый класс в свою очередь разделяется на <br/>
        единицы, десятки и сотни <img src='./images/algebra/1.png'/>
        Пример отрезка <img src='./images/algebra/2.png'/> длину отрезка можно измерять милиметрами, сантиметрами, дециметрами<br/>
        метрами и километрами, измерить отрезок это подщитать сколько единичных отрезков в нем помещяются<br/>
        Два отрезка считаются равными если при наложении друг на друга их длина одинакова<br/>
        Прямая это геометрическая фигура которая не имеет концов, у луча есть начало но нет конца
        <img src='./images/algebra/3.png'/>
        <img src='./images/algebra/4.png'/>`
    },
    {
        title: 'PHP Zandstra',
        content: `В PHP 7 было введено обьявление скалярных типов данных, а так же анонимных классов<br/>
        Класс это шаблон кода для создания обьектов
        <img src='./images/php/1.png'/>
        В php 4 и 5.1 можно выводить классы непосредственным путем но начиная с php 5.2 нужно добавить метод __toString()<br/>
        private, protected и public определяют оюласть кода для которого метод будет доступным
        <img src='./images/php/2.png'/>
        Передавать значения вышеуказаным способом не принятая практика, потому что создавая класс мы подразумеваем что у него уже есть<br/>
        свойство title<br/>
        В отличии от функции методы обьявляются внутри класса
        <img src='./images/php/3.png'/>
        public - открытый можно использовать за пределами класса<br/>
        Метод __construct вызывается при создании экземпляра класса, как и __toString() это магический метод, до php 5 метод __construct<br/>
        совпадал с именем класса, в php 8 обьявлять свойства можно в конструкторе<br/>
        <img src='./images/php/4.png'/>`
    },
    {
        title: 'PHP & Lighthouse',
        content: `Для установки можно воспользоваться официальным сайтом lighthouse-php.com, внутри laravel <br/>
        создасться директория graphql с файлом schema.graphql <br/>
        php artisan vendor:publish --tag=lighthouse-config в папке config создаст файл lighthouse.php с настройками graphql для laravel
        <img src='./images/php/5.png'/>
        ВОсклицательный знак означает required`
    },
    {
        title: 'Computer science',
        content: `Алгоритм белого списка (White List) — это подход, при котором разрешаются только заранее определённые и<br/>
        проверенные значения (например, данные, действия, IP-адреса или маршруты). Всё, что не входит в список, автоматически блокируется.
        <img src='./images/php/6.png'/>`
    },
    {
        title: 'PHP Zandstra',
        content: `В PHP 8 появились именованные аргкменты для методов
        <img src='./images/php/7.png'/>
        Для проверки типов данных использутся функции которые возвращают true/false
        <img src='./images/php/8.png'/>
        <img src='./images/php/9.png'/>
        С 5-й версии php были добавлены обьявления типов данных для методов, если не следовать канонам типизации то получим TypeError<br/>
        Если нужно создать необьязательный аргумент то можно воспользоваться следующим кодом function test(array $arr = null)<br/>
        php 8 - mixed означает смешанные типы данных
        <img src='./images/php/10.png'/>
        До php 8 обьявления переменных с несколькоми типами можно было сделать только в теле метода тепер это можно сделать так int|string|float<br/>
        Если переменная может получить тип null то ее можно определить следующим образом function test(string ?$arg)<br/>
        Можно обьявить тип возвращающего значения function test(string ?$arg): int<br/>
        Тип void возвращает ничего<br/>
        Наследование позволяет создовать несколько классов из одного базового`
    },
    {
        title: 'PHP & Lighthouse',
        content: `Schema похожа на схему в базах данных она описывает данные, есть 3 корневые типы Query, mutation и Subscription<br/>
        Scalar это определенные в type-ах значения типо int, string Id и так далее<br/>
        $carbon->diffForHumans() возвратит время как 38 minutes ago<br/>
        Определения скаляров можно таким образом
        <img src='./images/php/11.png'/>
        Директивы это очень мощный инструмент lighthouse
        <img src='./images/php/12.png'/>`
    },
    {
        title: 'Computer science',
        content: `Алгоритм бинарного поиска Объяснение работы: Массив должен быть отсортирован. Бинарный поиск работает только<br/>
        с отсортированными данными. Идея алгоритма: Делим массив на две половины. Сравниваем искомое число ($target) со<br/>
        средним элементом: Если совпадает — возвращаем индекс. Если меньше — продолжаем поиск в левой половине.<br/>
        Если больше — продолжаем поиск в правой половине. Повторяем до нахождения элемента или завершения диапазона.<br/>
        <img src='./images/php/13.png'/>`
    },
    {
        title: 'PHP Zandstra',
        content: `Класс наследованный от другого класса называется подклассом, как правило дочерний класс расширяет функционал родительского класса<br/>
        $someClass instanceof MainClass - instanceof возвращает true или false если переменная является обьектом MainClass<br/>
        ChildClass extends ParentClass оператор extends отвечает за наследования, при создании дочернего класса будет вызываться так<br/>
        же констрктор родительского класса, каждый класс наследует свойства родительского класса и может расширять и менять эти свойства<br/>
        Вот как выглядит расширения сврйств конструктора дочернего класса 
        <img src='./images/php/14.png'/>
        public можно получить доступ из любого контекста<br/>
        protected доступ только внутри класса и подклассов <br/>
        private доступ только внутри класса, даже подклассы не имеют доступа к таким методам и свойствам<br/>
        Доступ к методам и свойствам можно получать в контексте класса, а не объекта. Такие методы и свойства являются<br/>
        статическими и должны быть объявлены с помощью ключевого
        слова static`
    },

    {
        title: 'PHP Zandstra',
        content: `Доступ к статистическому свойству осуществляется через класс а не через экземпляр обьекта ClassName::staticMethod()<br/>
        Чтобы получить доступ к статическому методу или свойству из того же самого класса ( а не из дочернего класса ),<br/>
        мы пользуемся ключевым словом self. Ключевое слово self служит для обращения к текущему классу подобно<br/>
        тому, как псевдопеременная $this к текущему объекту.
        <img src='./images/php/15.png'/>
        Полезность статических методов и свойств Во- вторых, статическое свойство доступно каждому экземпляру объекта данного класса<br/>
        Поэтому так можно определить значения, которые должны быть доступны всем объектам данного типа. И, наконец, благодаря тому<br/>
        что отпадает необходимость в наличии экземпляра класса для доступа к его статическому свойству или методу, можно<br/>
        избежать создания экземпляров объектов исключительно ради вызова простой функции<br/>
        PDO означает РНР Data Object ( Объект данных РНР ). А класс PDO обеспечивает универсальный интерфейс для различных<br/>
        приложений баз данных.<br/>
        Термин фабрика относится к коду, предназначенному для создания экземпляров объектов<br/>
        const TEST_TEST = 37; постоянное свойство которое нельзя изменить, всегда примитивные значения<br/>
        Абстрактный класс отличается тем, что невозможно создать его экземпляр. Вместо этого в нем определяется ( и, возможно<br/>
        частично реализуется ) интерфейс для любого класса, который может его расширить.
        Как правило, в абстрактном классе должен содержаться по меньшей мере один абстрактный метод. Как и абстрактный класс<br/>
        он объявляется с помощью ключевого слова abstract. Абстрактный метод не может быть реализован в абстрактном классе.<br/>
        Он объявляется как обычный метод, но объявление завершается точкой с запятой, а не телом метода
        <img src='./images/php/16.png'/>
        В отличии от абстрактных классов где возможна некоторая реализация методов интерфейсы являются полными шаблонами
        <img src='./images/php/17.png'/>
        Class Test implements Chargable {}<br/>
        В php только одиночное наследование поэтому после слово extends пишем один класс но после implements можем добавить много интерфейсов<br/>
        class Consultancy extends TimedService implements Bookable, Chargeable {}`
    },
    {
        title: 'PHP & Lighthouse',
        content: `Директива @all выбирет все данные из модели
        <img src='./images/php/18.png'/>`
    },
    {
        title: 'Laravel Documentation',
        content: `Можно установить установщик ларавел composer global require laravel/installer и после устанавливать новые проекты<br/>
        таким образом laravel new example-app<br/>
        Все файлы конфигурации Laravel хранятся в каталоге config<br/>
        важные параметры конфигурации задаются в файле .env<br/>
        Файл .env не следует добавлять в систему контроля версий вашего приложения, так как различные разработчики и серверы могут<br/>
        требовать разные настройки окружения<br/>
        php artisan migrate после создания проекта выполнит все необходимые миграции`
    },
    {
        title: 'Computer science',
        content: `Алгоритм сортировки вставкой работает так: Разделяем массив: считаем, что первый элемент уже отсортирован.<br/>
        Берём следующий элемент и сравниваем с предыдущими. Сдвигаем элементы, которые больше текущего, вправо.<br/>
        Вставляем текущий элемент на его правильное место. Повторяем, пока весь массив не станет отсортированным.<br/>
        Пример работы: Для массива [5, 2, 9, 1]: Сначала [5] — отсортировано. 2 < 5 → сдвигаем 5 и вставляем 2: [2, 5].<br/>
        9 > 5 → оставляем как есть: [2, 5, 9]. 1 < 2 → сдвигаем все вправо и вставляем 1: [1, 2, 5, 9].<br/>
        Это просто и эффективно для маленьких массивов.
        <img src='./images/php/19.png'/>
        Сортировка вставкой полезна, когда: Массив небольшой (до ~10-20 элементов) — алгоритм работает быстро, так как не<br/>
        требует много операций. Массив почти отсортирован — если элементы уже близки к нужному порядку, сортировка вставкой работает<br/>
        очень эффективно. Недостатки: Для больших массивов алгоритм медленный, так как имеет сложность Не подходит для сортировки<br/>
        больших данных. Если хочешь производительности, лучше использовать быструю сортировку или сортировку слиянием.`
    },
    {
        title: 'Go',
        content: `Полезен для создания веб сервисов, файлы имеют расширение .go`
    },
];

let lessonsHtml = '<div>';
const mainElement = document.querySelector('main');
let lessonCount = 0;

lessons.forEach(lesson => {
    lessonCount += 1;
    lessonsHtml += `
        <div class='lesson'>
            <h3>${lesson.title}</h3>
            <p>${lesson.content}</p>
            <p><b>-${lessonCount}-</b></p>
        </div>
    `
});

lessonsHtml += '</div>';
mainElement.innerHTML = lessonsHtml;